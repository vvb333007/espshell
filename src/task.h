/* 
 * This file is a part of the ESPShell Arduino library (Espressif's ESP32-family CPUs)
 *
 * Latest source code can be found at Github: https://github.com/vvb333007/espshell/
 * Stable releases: https://github.com/vvb333007/espshell/tags
 *
 * Feel free to use this code as you wish: it is absolutely free for commercial and 
 * non-commercial, education purposes.  Credits, however, would be greatly appreciated.
 *
 * Author: Viacheslav Logunov <vvb333007@gmail.com>
 */

// -- Tasks --
// Think wrapper for FreeRTOS' task functions
//

#if COMPILING_ESPSHELL

#define task_t     TaskHandle_t
#define taskfunc_t TaskFunction_t

extern task_t loopTaskHandle;  // task handle of a task which calls Arduino's loop(). Defined somewhere in the ESP32 Arduino Core
static task_t shell_task = 0;  // Main espshell task ID
static int          shell_core = 0;  // CPU core number ESPShell is running on. For single core systems it is always 0

// Signals for use in task_signal(), task_signal_from_isr() and task_wait_for_signal() functions
//
#define SIGNAL_TERM 0  // Request to terminate. (Must be zero, DO NOT CHANGE its default value)
#define SIGNAL_GPIO 1  // "Pin interrupt" signal. Generated by GPIO ISR.
#define SIGNAL_KILL 2  // Force task deletion. This value can be sent but can't be received
#define SIGNAL_HUP  3  // "Reinitialize/Re-read configuration" (Unused, for future extensions)


// current task id
#define taskid_self() \
  xTaskGetCurrentTaskHandle()

#define task_new(func, arg) \
  ({ \
    task_t handle; \
    if (pdPASS != xTaskCreatePinnedToCore((TaskFunction_t)func, "Async", STACKSIZE, arg, tskIDLE_PRIORITY, &handle, shell_core)) \
      handle = 0; \
    handle; \
  })

#define task_finished() \
  vTaskDelete(NULL)

// Task signalling wrappers. qlib is used in a few different projects so I try to keep it easily convertible to other API
// (POSIX for example). 

// Send a signal (uin32_t arbitrary value) to the task.If task was blocking on task_signal_wait() the task will unblock
// and receive signal value
#define task_signal(_Handle, _Signal) \
  xTaskNotify((task_t)(_Handle), _Signal, eSetValueWithOverwrite)

// Same as above but ISR-safe
#define task_signal_from_isr(_Handle, _Signal) \
  { \
    BaseType_t force_yield; \
    xTaskNotifyFromISR((task_t)(_Handle), _Signal, eSetValueWithOverwrite, &force_yield); \
    if (force_yield) \
      portYIELD_FROM_ISR(); \
  }

// Block until any signal is received but not longer than /timeout/ milliseconds. Value of 0xffffffff (DELAY_INFINITE) means "infinite timeout":
// function will block until it receives ANY signal; the signal value is returned in /*sig/, pointer can be NULL;
// 
// Returns /true/ if signal was received
// Returns /false/ if timeout has fired before any signal was received
//
static bool task_wait_for_signal(uint32_t *sig, uint32_t timeout_ms) {

  bool loop = false;
  uint32_t sig0;

  // portMAX_DELAY is not an infinite value, it is 0xffffffff which is about 1200 hours
  if (timeout_ms == DELAY_INFINITE) {
    timeout_ms = portMAX_DELAY;
    loop = true;
  } else 
    timeout_ms = pdMS_TO_TICKS(timeout_ms); 
 
  if (NULL == sig)
    sig = &sig0;

  // block until any notification or timeout
  if (!loop)
    return xTaskNotifyWait(0, 0xffffffff, sig, timeout_ms ) == pdPASS;

  // block until any notification
  while( xTaskNotifyWait(0, 0xffffffff, sig, timeout_ms ) != pdPASS ) {}

  return true;
}


// Can we perform commands on this taskid?
// The task must be not the espshell's main task AND taskid must be in a valid address range
//
static bool taskid_good(unsigned int taskid) {

  // Use range of "1" for now. TODO: change it to the sizeof(TaskHandle)
  if (!is_valid_address((void *)taskid,1)) {
    HELP(q_print("% Task ID is a <i>hex number</>, something like \"3ffb0030\" or \"0x40005566\"\r\n"));
    return false;
  }
  
  // Ignore attempts to manipulate the main espshell task
  if (shell_task == (task_t )taskid) {
    HELP(q_printf("%% Task <i>0x%x</> is the main espshell task, access denied :)\r\n",taskid));
    return false;
  }

  return true;
}

// check if *this* task (a caller) is executed as separate (background) task
// or it is executed in context of ESPShell
//
static INLINE bool is_foreground_task() {
  return shell_task == taskid_self();
}

#define is_background_task() (!is_foreground_task())


// check if ESPShell's task is already created
static INLINE bool espshell_started() {
  return shell_task != NULL;
}



//"suspend"
// suspends main Arduino task (i.e loop())
static int cmd_suspend(int argc, char **argv) {

  unsigned int taskid;
  task_t sus = loopTaskHandle;
  if (argc > 1) {
    taskid = hex2uint32(argv[1]);
    if (taskid_good(taskid)) 
      sus = (task_t )taskid; 
    else 
      return 1;
  }
  vTaskSuspend(sus);
  
  return 0;
}

//"resume"
// Resume previously suspended task
//
static int cmd_resume(int argc, char **argv) {
  unsigned int taskid;
  task_t sus = loopTaskHandle;
  if (argc > 1) {
    taskid = hex2uint32(argv[1]);
    if (taskid_good(taskid)) sus = (task_t )taskid; else return 1;
  }
  vTaskResume(sus);
  return 0;
}

//"kill [-term|-kill|-9|-15] TASK_ID"
// 1. Stop a background command
// 2. Terminate arbitrary FreeRTOS task
//
static int cmd_kill(int argc, char **argv) {

  unsigned int sig = SIGNAL_TERM, i = 1, taskid;
  if (argc < 2)
    return CMD_MISSING_ARG;

  if (argv[i][0] == '-') { // an option, task id follows
    q_tolower(argv[i]);
    if (!q_strcmp(argv[i],"-term") || !q_strcmp(argv[i],"-15")) sig = SIGNAL_TERM; else
    if (!q_strcmp(argv[i],"-hup") ||  !q_strcmp(argv[i],"-1")) sig = SIGNAL_HUP; else
    if (!q_strcmp(argv[i],"-kill") || !q_strcmp(argv[i],"-9"))  sig = SIGNAL_KILL; else return 1;
    i++;
  }

  if (i >= argc)
    return CMD_MISSING_ARG;

  if (taskid_good((taskid = hex2uint32(argv[i])))) {
    // SIGNAL_KILL is never sent to a task. Instead, task is deleted.
    if (sig == SIGNAL_KILL) {
      vTaskSuspend((task_t )taskid);
      q_delay(1);
      vTaskDelete((task_t )taskid);
      HELP(q_printf("%% Killed: \"0x%x\". Resources are not freed!\r\n", taskid));
    } else
      // -term, -hup and other signals are sent directly to the task
      task_signal(taskid, sig);
  } else
    return i;
  return 0;
}

#endif // COMPILING_ESPSHELL

