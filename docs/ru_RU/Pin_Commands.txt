ESP32Shell for the Arduino Framework by vvb333007 <vvb@nym.hush.com>


Пины (GPIO) чипа ESP32, общие сведения
--------------------------------------

У ESP32 есть большое количество пинов, кждый из которых (за небольшими
исключениями) может выполнять как функцию пина общего назначения, так
и быть соединеным с одним из внутренних сигналов: например быть TX пином
интерфейса UART. Эта особенность ESP32 позволяет сконфигурировать любой
интерфейс из доступных на любых пинах.

Однако:

Некоторые пины имеют специальное назначение и оказывают влияние на
процесс загрузки. Использовать их можно, но нужно держать их в дефолтном
состоянии на момент загрузки. 

Некоторые пины зарезервированы для внутренних нужд; например пины 6..11
на большинстве систем используются для доступа к flash-памяти и SPIRAM,
поэтому использовать их нельзя. 

Некоторые пины сконфигурированы как OUTPUT и это никак нельзя изменить

Espshell предоставляет возможность поиграться с пинами в известных пределах
с помощью команды "pin". Это команда выводит текущее состояние пина, 
позволяет менять настройки пина (INPUT/OUTPU/PULL), считывать и записывать
логический уровень, считывать аналоговый сигнал, посылать последовательности
импульсов и т.п. В процессе написания\отладки Ардуино-скетча эта команда
может сэкономить время на бесконечные "исправил\скомпилировал\перепрошил".


Информация о пине
-----------------
Чтобы получить общую информацию о пине, скажем, 2, нужно выполнить команду
"pin 2". Пример:

  esp32#>pin 2
  % Digital pin value = 1
  IO[2] -
    Pullup: 0, Pulldown: 1, DriveCap: 2
    InputEn: 1, OutputEn: 1, OpenDrain: 0
    FuncSel: 2 (GPIO)
    GPIO Matrix SigOut ID: 256 (simple GPIO output)
    GPIO Matrix SigIn ID: (simple GPIO input)
    SleepSelEn: 0




Конфигурирование пина
---------------------

(Можно сразу промотать до примеров, там нагляднее)


Команда "pin" всегда имеет как минимум один аргумент - номер пина. 
И в таком простомвиде эта команда выводит информацию о пине на экран. Если же 
после номера пина идут дополнительные аргументы, то команда "pin" начинает
/выполнять/ эти аргументы по-порядку. Аргументы могут идти в любом порядке
и повторяться, максимальное количество аргументов - 255 на одну команду
"pin"


А вот и все возможные аргументы для команды "pin":

out     - Пин сконфигурирован как OUTPUT
in      - Пин сконфигурирован как INPUT

up      - Внутренний pull-up резистор (~45k)
down    - Внутренний pull-down резистор (~45k)
open    - Пин с флагом OPEN_DRAIN

high    - Установить логическую "1" на пине
low     - Установить логический "0"
seq X   - Передать последовательность номер X (см. docs/ru_RU/Pulse_Generator.txt)

delay X - Сделадь задержку в X миллисекунд перед тем как перейти к следующему
          аргументу (см. Пример 5, ниже)

save    - Запомнить состояние пина (для последующего восстановления).

load    - Восстановить состояние пина, как оно было на момент сохранения 
          (см. "save")

read    - digitalRead() 
aread   - analogRead()

hold    - "заморозить" пин в его текущем состоянии. Разморозить пин можно или
          комадой "release" (см. ниже) или перезагрузкой по питанию. 
          Замороженный пин никак не реагирует на попытки что-либо с ним сделать,
          а так же удерживает логический уровень, если пин был сконфигурирован
          как OUTPUT

release - "разморозить" пин, который перед этим был заморожен командой "hold"



Некоторые примеры использования команды "pin"


Пример 1: вывести на экран информацию о пине 2
----------------------------------------------

   esp32#>pin 2


Пример 2. Сконфигурировать пин 33 OUTPUT и INPUT, PULL_UP и установить 
          уровень логической "1"
------------------------------------------------------------------------

   esp32#>pin 33 out in up high


Пример 3. Запомнить состояяние пина, переконфигурировать его в OUTPUT, HIGH, а 
          затем восстановить состояние пина
--------------------------------------------------------------------------------

   esp32#>pin 33 save out high
   esp32#>pin 33 load


Пример 4. Считать аналоговое значение пина 33 (analogRead(33))
--------------------------------------------------------------
   esp32#>pin 33 aread

   Обратите внимание: команда чтения аналогового значения в Ардуино сделана так,
   что она перенастраивает пин. И если вы вслед за "aread" попытаетесь прочитать
   логичесий уровень, то произойдет ошибка: пин надо конфигурить по-новой, чтобы 
   он выполнял функцию GPIO и отвечал на digitalRead().

   Чтобы такого неприятного поведения избежать, можно использовать команды "load"
   и "save", например, так:

   esp32#>pin 33 read save aread load

   Команда выполнит "digitalRead()", затем сохранит состояние пина, считает аналоговое
   значение и затем восстановит состояние пина до исходного

Пример 5, Сохранить состояние пина, потом "поморгать" пином: держать высокий уровень
          250 мс, затем низкий уровень на 100 мс, затем опять высокий на 50 мс а затем 
          восстановить состояние пина
--------------------------------------------------------------------------------------

  esp32#>pin 33 save out high delay 250 low delay 100 high delay 50 load
  
  Примечание: Да, с помощью delay можно создавать простенькие последовательности.
              Для более сложных последовательностей, с точным таймингом лучше 
              использовать встроенный генератор сигнала (см. docs/ru_RU/Pulse_Generator.txt),
              а для генерации импульсов фикированной частоты можно использовать команду
              "tone" (см. docs/ru_RU/Tone_Generator_And_Counter.txt)

Пример 6: То же, что и в Примере 5, но добавить чтение пина после каждой задержки
---------------------------------------------------------------------------------

esp32#>pin 33 save out high delay 250 read low delay 100 read high delay 50 read load


Еще несколько простых примеров команд espshell и их эквивалента в скетче для Ардуино

pin 12 out high             - pinMode(12,OUTPUT); digitalWrite(12,HIGH);
pin 12 out up open          - pinMode(12, OUTPUT | PULLUP | OPEN_DRAIN);
pin 12 in up                - зinMode(12, INPUT_PULLUP);
pin 12 read save aread load - digitalRead(12); analogRead(12);

