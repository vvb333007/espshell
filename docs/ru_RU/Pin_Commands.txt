ESP32Shell for the Arduino Framework by vvb333007 <vvb@nym.hush.com>


Пины (GPIO) чипа ESP32, общие сведения
--------------------------------------

У ESP32 есть большое количество пинов, каждый из которых (за небольшими
исключениями) может выполнять как функцию пина общего назначения, так
и быть соединеным с одним из внутренних сигналов: например быть TX пином
интерфейса UART. Эта особенность ESP32 позволяет сконфигурировать любой
интерфейс из доступных на любых пинах.

Однако:

Некоторые пины имеют специальное назначение и оказывают влияние на
процесс загрузки. Использовать их можно, но нужно держать их в дефолтном
состоянии на момент загрузки. 

Некоторые пины зарезервированы для внутренних нужд; например пины 6..11
на большинстве систем используются для доступа к flash-памяти и SPIRAM,
поэтому использовать их нельзя.  Такие пины будут помечены как **RESERVED** 
при выводе на экран информации о них.

Некоторые пины сконфигурированы как INPUT и это никак нельзя изменить.

Espshell предоставляет возможность поиграться с пинами в известных пределах
с помощью команды "pin". Это команда выводит текущее состояние пина, 
позволяет менять настройки пина (INPUT/OUTPU/PULL), считывать и записывать
логический уровень, считывать аналоговый сигнал, посылать последовательности
импульсов и т.п. В процессе написания\отладки Ардуино-скетча эта команда
может сэкономить время на бесконечные "исправил\скомпилировал\перепрошил".


В отличии от стандртной для Arduino функции digitalRead(), espshell может
читать значения любых пинов, включая те, которые не сконфигурированы как
GPIO: например, можно считывать значения с I2C линии, или UART_TX/UART_RX.
Таким образом можно наблюдать состояние "живых", работающих пинов, например,
можно считывать значения с PWM (ledc) пина, в тот момент, когда он 
используется для генерации PWM сигнала. То, что PWM пин, возможно, был 
сконфигурирован как OUTPUT-only значения для ESPShell не имеет: пин будет
сконфигурирован как надо, автоматически, и значение будет прочитано.


Информация о пине
-----------------
Чтобы получить общую информацию о пине, скажем, 2, нужно выполнить команду
"pin 2". Примеры:

  esp32#>pin 0
  % Pin 0 is strapping pin, available, not configured
  % Mode: INPUT, PULL_UP,
  % Input is routed through IO MUX
  % Maximum current is 20 milliamps


  esp32#>pin 8
  % Pin 8 is **RESERVED**, available, not configured
  % Mode: INPUT, OUTPUT, PULL_UP,
  % Output via GPIO matrix, provides path for signal ID: 2
  % Input via GPIO matrix, provides path for signal IDs: 2,
  % Maximum current is 20 milliamps

  Примечание:  пометка **RESERVED** означает, что пользоваться данным пином нельзя: он используется
  для внутренних нужд процессора. Это может быть интерфейс с внешней памятью или FLASH памятью из
  которой исполняется ваша программа. Работа с этими пинами скорее всего приведет к перезагрузке

  esp32#>pin 43
  % Pin 43 is used as "UART_TX"
  % Mode: INPUT, PULL_UP,
  % Input is routed through IO MUX
  % Maximum current is 20 milliamps

  esp32#>pin 4
  % Pin 4 is available, not configured
  % Maximum current is 20 milliamps
esp32#>



Конфигурирование пина
---------------------

(Можно сразу промотать до примеров, там нагляднее)


Команда "pin" всегда имеет как минимум один аргумент - номер пина: в таком 
простом виде эта команда выводит информацию о пине на экран. 

Если же после номера пина идут дополнительные аргументы, то команда "pin" 
начинает /выполнять/ эти аргументы по-порядку. Аргументы могут идти в любом 
порядке и повторяться, максимальное количество аргументов - 255 на одну команду
"pin"


Ниже в табличке приведены все возможные аргументы для команды "pin". Они сгруппированы
по смысловой нагрузке: первыми идут команды конфигурирования пина, затем команды выводящие
сигнал на пин, затем команды чтения пина и прочие команды


out      - Сконфигурировать пин как OUTPUT
in       - Сконфигурирован пин как INPUT
up       - Включить внутренний pull-up резистор (~45k)
down     - Включить внутренний pull-down резистор (~45k)
open     - Установить флаг OPEN_DRAIN (pinMode(..., OPEN_DRAIN))

high     - Установить логическую "1" на выходе. Автоматически переводит пин в режим OUTPUT.
low      - Установить логический "0" на выходе  Автоматически переводит пин в режим OUTPUT.
seq X    - Передать последовательность номер X (см. "docs/ru_RU/Pulse_Generator.txt")
pwm X Y  - Велючить генератор сигнала с частотой X (в герцах) и скважностью (duty) Y
           Величчина Y задается как число с плавающей точкой, в диапазоне от 0 до 1

read     - Считать значение с пина digitalRead(). Корректно считывает значения любых пинов,
           в том числе значения с пинов, не сконфигурированных, как GPIO: например LEDC или 
           UART.Если пин был в режиме OUTPUT, то к этому режиму дополнительно будет включен 
           INPUT.

aread    - Считать значение с пина analogRead()

save     - Запомнить состояние пина (для последующего восстановления).
load     - Восстановить состояние пина, как оно было на момент сохранения 
           (см. "save")


hold     - "заморозить" пин в его текущем состоянии. Разморозить пин можно или
           комадой "release" (см. ниже) или перезагрузкой по питанию. 
           Замороженный пин никак не реагирует на попытки что-либо с ним сделать,
           а так же удерживает логический уровень, если пин был сконфигурирован
           как OUTPUT
release  - "разморозить" пин, который перед этим был заморожен командой "hold"

delay X  - Сделать задержку в X миллисекунд перед тем как перейти к следующему
           аргументу (см. Пример 5, ниже)

loop X   - повторять всю комманду X раз.
           Если решили использовать "loop", то обратите внимание на то, что это
           должен быть последний параметр команды "pin":

           Правильно:    esp32#>pin 2 out high delay 500 low delay 500 loop 10
           НЕ правильно: esp32#>pin 2 out high delay 500 low delay 500 loop 10 read

           Прервать выполнение такой зацикленной команды раньше времени можно нажав
           любую клавишу в терминале или отослав любой символ в Arduino IDE Serial
           Monitor

 X       - Номер. Целое число задающее пин, с которым мы работаем в данный момент
           Пример: установить пины 3 и 4 в значение логической 1, а пины 5 и 6 - в
           логический ноль

               esp32#>pin 3 high 4 high 5 low 6 low



Рассмотрим примеры использования команды "pin" с разными аргументами, откуда
станет понятно использование большинства из них. Примеры следует прочитать все
и по порядку, вместе с примечаниями.


Пример 1: вывести на экран информацию о пине 2
----------------------------------------------

   esp32#>pin 2


Пример 2. Сконфигурировать пин 33 OUTPUT и INPUT, PULL_UP и установить 
          уровень логической "1"
------------------------------------------------------------------------

   esp32#>pin 33 out in up high

   ПРИМЕЧАНИЕ: установка пина в 0 (low) или 1 (high) подразумевает то, что пин должен
   быть сконфигурирован на выход (OUTPUT), поэтому каждая "low" или "high" команда
   добавляет неявный аргумент "out"перед "low" и перед "high". Таким образом, пример
   выше может быть записан и в таком виде:

   esp32#>pin 33 in up high

Пример 3. Установить пин 22 в низкое значение а 23 в высокое
------------------------------------------------------------
  esp32#>pin 22 low
  esp32#>pin 23 high

  А можно и одной строчкой:

  esp32#>pin 22 high 23 low

  Так - правильно:           esp32#>pin 1 low 10 low  (оба пина будут LOW)
  А вот так - неправильно:   esp32#>pin 1 10 low      (только пин 10 будет LOW)


Пример 4. Запомнить состояяние пина, переконфигурировать его в OUTPUT, HIGH, а 
          затем восстановить состояние пина
--------------------------------------------------------------------------------

   esp32#>pin 33 save out high
   esp32#>pin 33 load

Пример 5. Мигнуть светодиодом на пине 2 20 раз, с интервалом в пол-секунды
--------------------------------------------------------------------------

  esp32#>pin 2 out high delay 500 low delay 500 loop 20

  ПРИМЕЧАНИЕ: если используются задержки длиной более 4999 миллисекунд, то команда
  "pin" начинает реагировать на нажатия клавиш: посылка любого символа в Arduino IDE
  Serial Monitor, или нажатие любой клавиши в терминале (мне TeraTerm нравится, например)
  прервет выполнение команды "pin". Если у вас длинная команда "pin" с кучей задержек,
  то нет необходимости дожидаться окончания работы команды - ее можно прервать нажатием 
  любой клавиши. Если задержки менее 4999мс, то такие задержки не прерываются, даже если
  суммарно этих задержек в комманде дано на час.
  

Пример 5.1. Мигнуть светодиодом на пине 2 20 раз, с интервалом в пол-секунды,
            с яркостью 50%
-----------------------------------------------------------------------------


  esp32#>pin 2 pwm 5000 0.5 delay 500 pwm 0 0 delay 500 loop 20
       
  Здесь мы включаем генератор 5кГц, со скважностью 50% на полсекунды,
  затем выклюючаем. Повторяем последовательность 20 раз с помощью команды "loop 20"

  ПРИМЕЧАНИЕ: наличие "loop" в команде "pin" автоматически делает команду прерываемой:
  "pin" начинает реагировать на нажатия клавиш: посылка любого символа в Arduino IDE
  Serial Monitor, или нажатие любой клавиши в терминале  прервет выполнение команды.



Пример 6. Считать аналоговое значение пина 33 (analogRead(33))
--------------------------------------------------------------

   esp32#>pin 33 aread

   Обратите внимание: функция чтения аналогового значения в Ардуино сделана так,
   что она перенастраивает пин. И если вы вслед за "aread" попытаетесь прочитать
   логичесий уровень, то произойдет ошибка: пин надо конфигурить по-новой, чтобы 
   он выполнял функцию GPIO и отвечал на digitalRead().

   Чтобы такого неприятного поведения избежать, можно использовать команды "load"
   и "save", например, так:

   esp32#>pin 33 read save aread load

   Команда выполнит "digitalRead()", затем сохранит состояние пина, считает аналоговое
   значение и затем восстановит состояние пина до исходного


Пример 7, Сохранить состояние пина, потом "поморгать" пином: держать высокий уровень
          250 мс, затем низкий уровень на 100 мс, затем опять высокий на 50 мс а затем 
          восстановить состояние пина
--------------------------------------------------------------------------------------

  esp32#>pin 33 save high delay 250 low delay 100 high delay 50 load
  
  Примечание: Да, с помощью delay можно создавать простенькие последовательности.
              Для более сложных последовательностей, с точным таймингом лучше 
              использовать встроенный генератор сигнала (см. docs/ru_RU/Pulse_Generator.txt),
              а для генерации импульсов фикированной частоты можно использовать команду
              "pwm" (см. docs/ru_RU/Tone_Generator_And_Counter.txt)


Пример 8:  Установить пин 2 в значение HIGH, пин 3 в значение LOW. Через полсекунды
           поменять нзначение на противоположное
-----------------------------------------------------------------------------------

  esp32#>pin 2 high 3 low delay 500 2 low 3 high


Еще несколько простых примеров команд espshell и их эквивалента в скетче для Ардуино

pin 12 out high             - pinMode(12,OUTPUT); digitalWrite(12,HIGH);
pin 12 out up open          - pinMode(12, OUTPUT | PULLUP | OPEN_DRAIN);
pin 12 in up                - pinMode(12, INPUT_PULLUP);
pin 12 read save aread load - digitalRead(12); analogRead(12);


Экспериментируйте!
