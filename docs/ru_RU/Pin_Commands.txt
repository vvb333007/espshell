ESP32Shell for the Arduino Framework by vvb333007 <vvb@nym.hush.com>


ПИНЫ (GPIO) ЧИПА ESP32, ОБЩИЕ СВЕДЕНИЯ
--------------------------------------

У ESP32 есть большое количество пинов, каждый из которых (за небольшими
исключениями) может выполнять как функцию пина общего назначения, так
и быть соединеным с одним из внутренних сигналов: например быть TX пином
интерфейса UART. Эта особенность ESP32 позволяет сконфигурировать любой
интерфейс из доступных на любых пинах.

Однако:

Некоторые пины имеют специальное назначение и оказывают влияние на
процесс загрузки. Использовать их можно, но нужно держать их в дефолтном
состоянии на момент загрузки. 

Некоторые пины зарезервированы для внутренних нужд; например пины 6..11
на большинстве систем используются для доступа к flash-памяти и SPIRAM,
поэтому использовать их нельзя.  Такие пины будут помечены как **RESERVED** 
при выводе на экран информации о них.

Некоторые пины сконфигурированы как INPUT и это никак нельзя изменить.

Espshell предоставляет возможность поиграться с пинами в известных пределах
с помощью команды "pin". Это команда выводит текущее состояние пина, 
позволяет менять настройки пина (INPUT/OUTPU/PULL), считывать и записывать
логический уровень, считывать аналоговый сигнал, посылать последовательности
импульсов и т.п. В процессе написания\отладки Ардуино-скетча эта команда
может сэкономить время на бесконечные "исправил\скомпилировал\перепрошил".


В отличии от стандртной для Arduino функции digitalRead(), espshell может
читать значения любых пинов, включая те, которые не сконфигурированы как
GPIO: например, можно считывать значения с I2C линии, или UART_TX/UART_RX.
Таким образом можно наблюдать состояние "живых", работающих пинов, например,
можно считывать значения с PWM (ledc) пина, в тот момент, когда он 
используется для генерации PWM сигнала. То, что PWM пин, возможно, был 
сконфигурирован как OUTPUT-only значения для ESPShell не имеет: пин будет
сконфигурирован как надо, автоматически, и значение будет прочитано.


ПОЛУЧЕНИЕ ОБЩЕЙ ИНФОРМАЦИИ О ПИНЕ
---------------------------------
Чтобы получить общую информацию о пине, скажем, 2, нужно выполнить команду
"pin 2". Примеры:

  esp32#>pin 0
  % Pin 0 is strapping pin, available, not configured
  % Mode: INPUT, PULL_UP,
  % Input is routed through IO MUX
  % Maximum current is 20 milliamps


  esp32#>pin 8
  % Pin 8 is **RESERVED**, available, not configured
  % Mode: INPUT, OUTPUT, PULL_UP,
  % Output via GPIO matrix, provides path for signal ID: 2
  % Input via GPIO matrix, provides path for signal IDs: 2,
  % Maximum current is 20 milliamps

  Примечание:  пометка **RESERVED** означает, что пользоваться данным пином нельзя: он используется
  для внутренних нужд процессора. Это может быть интерфейс с внешней памятью или FLASH памятью из
  которой исполняется ваша программа. Работа с этими пинами скорее всего приведет к перезагрузке

  esp32#>pin 43
  % Pin 43 is used as "UART_TX"
  % Mode: INPUT, PULL_UP,
  % Input is routed through IO MUX
  % Maximum current is 20 milliamps

  esp32#>pin 4
  % Pin 4 is available, not configured
  % Maximum current is 20 milliamps
esp32#>



КОНФИГУРИРОВАНИЕ\ПРОГРАММИРОВАНИЕ ПИНА
--------------------------------------

(Можно сразу промотать до примеров, там нагляднее)


Команда "pin" всегда имеет как минимум один аргумент - номер пина: в таком 
простом виде эта команда выводит информацию о пине на экран. 

Если же после номера пина идут дополнительные аргументы, то команда "pin" 
начинает /выполнять/ эти аргументы по-порядку. Аргументы могут идти в любом 
порядке и повторяться, максимальное количество аргументов - 255 на одну команду
"pin"

Ниже в табличке приведены все возможные аргументы для команды "pin". Они сгруппированы
по смысловой нагрузке: первыми идут команды конфигурирования пина, затем команды выводящие
сигнал на пин, затем команды чтения пина и прочие команды. У команды "pin" может быть сколько
угодно этих аргументов - команда "pin" будет выполнять из по-порядку, слева направо.

Например, команда "pin 2 high 3 low delay 100 2 low 3 high" является вполне допустимой командой,
с десятью аргументами. Аргументы, в свою очередь, образуют подобие микропрограммы, которая и 
исполняется командой "pin". Так, в вышепревиденном примере на пины 2 и 3 подаются 1 и 0 соответственно.
Через 100 миллисекунд состояние пинов меняется на противоположное.


АРГУМЕНТЫ КОМАНДЫ "PIN"
-----------------------

out      - Сконфигурировать пин как OUTPUT
in       - Сконфигурирован пин как INPUT
up       - Включить внутренний pull-up резистор (~45k)
down     - Включить внутренний pull-down резистор (~45k)
open     - Установить флаг OPEN_DRAIN (pinMode(..., OPEN_DRAIN))

high     - Установить логическую "1" на выходе. Автоматически переводит пин в режим OUTPUT.
low      - Установить логический "0" на выходе  Автоматически переводит пин в режим OUTPUT.
seq X    - Передать последовательность номер X (см. "docs/ru_RU/Pulse_Generator.txt")
pwm X Y  - Велючить генератор сигнала с частотой X (в герцах) и скважностью (duty) Y
           Величчина Y задается как число с плавающей точкой, в диапазоне от 0 до 1

read     - Считать значение с пина digitalRead(). Корректно считывает значения любых пинов,
           в том числе значения с пинов, не сконфигурированных, как GPIO: например LEDC или 
           UART.Если пин был в режиме OUTPUT, то к этому режиму дополнительно будет включен 
           INPUT.

aread    - Считать значение с пина analogRead()

save     - Запомнить состояние пина (для последующего восстановления).
load     - Восстановить состояние пина, как оно было на момент сохранения 
           (см. "save")


hold     - "заморозить" пин в его текущем состоянии. Разморозить пин можно или
           комадой "release" (см. ниже) или перезагрузкой по питанию. 
           Замороженный пин никак не реагирует на попытки что-либо с ним сделать,
           а так же удерживает логический уровень, если пин был сконфигурирован
           как OUTPUT
release  - "разморозить" пин, который перед этим был заморожен командой "hold"

delay X  - Сделать задержку в X миллисекунд перед тем как перейти к следующему
           аргументу (см. Пример 5, ниже)

loop X   - повторять всю команду X раз.
           Если решили использовать "loop", то обратите внимание на то, что это
           должен быть последний параметр команды "pin":

           Правильно:    esp32#>pin 2 out high delay 500 low delay 500 loop 10
           НЕ правильно: esp32#>pin 2 out high delay 500 low delay 500 loop 10 read

           Прервать выполнение такой зацикленной команды раньше времени можно нажав
           любую клавишу в терминале или отослав любой символ в Arduino IDE Serial
           Monitor

 X       - Номер. Целое число задающее пин, с которым мы работаем в данный момент
           Пример: установить пины 3 и 4 в значение логической 1, а пины 5 и 6 - в
           логический ноль

               esp32#>pin 3 high 4 high 5 low 6 low



ПРИМЕРЫ
-------

Рассмотрим примеры использования команды "pin" с разными аргументами, откуда
станет понятно использование большинства из них. Примеры следует прочитать все
и по порядку, вместе с примечаниями.


  Пример 1: вывести на экран информацию о пине 2
  ----------------------------------------------
   esp32#>pin 2


  Пример 2. Сконфигурировать пин 33 OUTPUT и INPUT, PULL_UP и установить 
            уровень логической "1"
  ------------------------------------------------------------------------

   esp32#>pin 33 out in up high

   ПРИМЕЧАНИЕ: установка пина в 0 (low) или 1 (high) подразумевает то, что пин должен
   быть сконфигурирован на выход (OUTPUT), поэтому каждая "low" или "high" команда
   добавляет неявный аргумент "out"перед "low" и перед "high". Таким образом, пример
   выше может быть записан и в таком виде:

   esp32#>pin 33 in up high

  Пример 3. Установить пин 22 в низкое значение а 23 в высокое
  ------------------------------------------------------------

  esp32#>pin 22 low
  esp32#>pin 23 high

  А можно и одной строчкой:

  esp32#>pin 22 high 23 low

  Так - правильно:           esp32#>pin 1 low 10 low  (оба пина будут LOW)
  А вот так - неправильно:   esp32#>pin 1 10 low      (только пин 10 будет LOW)


  Пример 4. Запомнить состояяние пина, переконфигурировать его в OUTPUT, HIGH, а 
            затем восстановить состояние пина
  --------------------------------------------------------------------------------

   esp32#>pin 33 save out high
   esp32#>pin 33 load

  Пример 5. Мигнуть светодиодом на пине 2 20 раз, с интервалом в пол-секунды
  --------------------------------------------------------------------------

  esp32#>pin 2 out high delay 500 low delay 500 loop 20

  ПРИМЕЧАНИЕ: если используются задержки длиной более 4999 миллисекунд, то команда
  "pin" начинает реагировать на нажатия клавиш: посылка любого символа в Arduino IDE
  Serial Monitor, или нажатие любой клавиши в терминале (мне TeraTerm нравится, например)
  прервет выполнение команды "pin". Если у вас длинная команда "pin" с кучей задержек,
  то нет необходимости дожидаться окончания работы команды - ее можно прервать нажатием 
  любой клавиши. Если задержки менее 4999мс, то такие задержки не прерываются, даже если
  суммарно этих задержек в команде дано на час.
  

  Пример 5.1. Мигнуть светодиодом на пине 2 20 раз, с интервалом в пол-секунды,
              с яркостью 50%
  -----------------------------------------------------------------------------

  esp32#>pin 2 pwm 5000 0.5 delay 500 pwm 0 0 delay 500 loop 20
       
  Здесь мы включаем генератор 5кГц, со скважностью 50% на полсекунды,
  затем выклюючаем. Повторяем последовательность 20 раз с помощью команды "loop 20"

  ПРИМЕЧАНИЕ: наличие "loop" в команде "pin" автоматически делает команду прерываемой:
  "pin" начинает реагировать на нажатия клавиш: посылка любого символа в Arduino IDE
  Serial Monitor, или нажатие любой клавиши в терминале  прервет выполнение команды.



  Пример 6. Считать аналоговое значение пина 33 (analogRead(33))
  --------------------------------------------------------------

  esp32#>pin 33 aread

  Обратите внимание: функция чтения аналогового значения в Ардуино сделана так,
  что она перенастраивает пин. И если вы вслед за "aread" попытаетесь прочитать
  логичесий уровень, то произойдет ошибка: пин надо конфигурить по-новой, чтобы 
  он выполнял функцию GPIO и отвечал на digitalRead().

  Чтобы такого неприятного поведения избежать, можно использовать команды "load"
  и "save", например, так:

  esp32#>pin 33 read save aread load

  Команда выполнит "digitalRead()", затем сохранит состояние пина, считает аналоговое
  значение и затем восстановит состояние пина до исходного


  Пример 7, Сохранить состояние пина, потом "поморгать" пином: держать высокий уровень
            250 мс, затем низкий уровень на 100 мс, затем опять высокий на 50 мс а затем 
            восстановить состояние пина
  --------------------------------------------------------------------------------------

  esp32#>pin 33 save high delay 250 low delay 100 high delay 50 load
  
  Примечание: Да, с помощью delay можно создавать простенькие последовательности.
              Для более сложных последовательностей, с точным таймингом лучше 
              использовать встроенный генератор сигнала (см. docs/ru_RU/Pulse_Generator.txt),
              а для генерации импульсов фикированной частоты можно использовать команду
              "pwm" (см. docs/ru_RU/Tone_Generator_And_Counter.txt)


  Пример 8:  Установить пин 2 в значение HIGH, пин 3 в значение LOW. Через полсекунды
             поменять нзначение на противоположное
  -----------------------------------------------------------------------------------

  esp32#>pin 2 high 3 low delay 500 2 low 3 high


Еще несколько простых примеров команд espshell и их эквивалента в скетче для Ардуино

pin 12 out high             - pinMode(12,OUTPUT); digitalWrite(12,HIGH);
pin 12 out up open          - pinMode(12, OUTPUT | PULLUP | OPEN_DRAIN);
pin 12 in up                - pinMode(12, INPUT_PULLUP);
pin 12 read save aread load - digitalRead(12); analogRead(12);



КОМАНДА "PIN" В ФОНОВОМ РЕЖИМЕ (АСИНХРОННАЯ КОМАНДА "PIN ... &")
----------------------------------------------------------------

Если в команде "pin" используются такие аргументы как "delay" или "loop", то такая
команда может выполнятся весьма долго. Конечно, можно нажать клавишу <Enter> и выполнение
команды прервется. Но что если мы хотим, чтобы команда не прерывалась, а выполнялась в фоне?
Например, нам не хочется дожидаться окончания команды потому, что команда - бесконечный цикл.

Типичный сценарий: мы генерируем последовательность импульсов с разными задержками и повторяем
жто последовательность в цикле бесконечно. В то же самое время мы хотим, чтобы команда не занимала
консоль и нам можно было бы вводить другие команды.

Так тоже можно: нужно использовать асинхронную версию команды : "pin .. &". Разница с командой
"pin" состоит лишь в том, "pin ... &" выполняется в фоне, отпускает консоль, и не прерывается 
нажатием <Enter>. Вместо этого, фоновое исполнение команды может быть прервано командой "kill":

  Пример:
  -------
  esp32#>pin& 2 low de 100 high de 100 loop 999999 &   <----- "&" = "исполнять в фоне"
  % Async "pin" command task ID is 3ffb9038
  % Use "kill 3ffb9038" to stop command execution
  esp32#>% Repeating 999999 times, press <Enter> to abort

В примере выше пин 2 последовательно меняет свое состояние между 0 и 1 с интервалов в 100
миллисекунд в течении очень долгого времени. Команда выполняеися в фоне и может быть прервана 
командой только "kill 3ffb9038", несмотря на надпись "..press <Enter> to abort": фоновые команды
не имеют доступа к вводу пользователя, поэтому не реагируют на нажатия клавиш.

Экспериментируйте!
