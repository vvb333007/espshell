ESP32Shell for the Arduino Framework by vvb333007 <vvb@nym.hush.com>


ESPShell позволяет задавать "вручную" последовательности логических
нулей и единиц, которые потом можно "проиграть" на выбраном пине,
причем длительность каждого нуля и единицы задается отдельно: таким
образом можно генерировать последовательности импульсов с заданными
характеристиками, включая те, что импользуются IR пультами.

ESP32 имеет на борту модуль, который называется RMT и предназначен
как раз для генерации таких последовательностей. Минимальная длина
импульса ограничена выбранным разрешением (см. ниже команду "tick")
с минимальным значением в 0.0125 мкс. Это означает, что самый короткий 
импульс, который может выдать RMT это импульс продолжительностью 0.0125 
микросекунд.


Команды espshell для создания и посылки последовательностей
-----------------------------------------------------------

В espshell можно создавать до 10 последовательностей. Каждая последовательность
имеет номер, от 0 до 9. Для начала редактирования последовательности 0
введем команду "sequence 0" или просто "seq 0"

После выполнения команды мы попадаем в подраздел конфигурирования 
последовательностей,о чем нам говорит изменившийся промпт (строка приглашения):

  esp32#>seq 0
  esp32-seq#>

Список команд, доступных в этом подразделе можно получить введя "?" и нажав
<Enter>:


  esp32#>seq 0
  esp32-seq#>?
  % Enter "command ?" to get details about the command.
  % List of available commands:
  %
  % "?"          : Show the list of available commands
  % "eot"        : End-of-Transmission pin state
  % "tick"       : Set resolution
  % "zero"       : Define a zero
  % "one"        : Define an one
  % "bits"       : Set pattern to transmit
  % "levels"     : Set levels to transmit
  % "modulation" : Enable/disable modulation
  % "show"       : Show sequence
  % "exit"       : Exit
 
  esp32-seq#>

Вместо того, чтобы описывать последовательно вышеприведенные команды,
мы перейдем сразу к примерам. Из примеров станет понятна большая часть
команд, а затем уже перейдем к сухому описанию.


Начнем с простой задачи: мы хотим на пине номер 2 проиграть следующую
последовательность:

"логическая 1 на 10мкс, затем 0 в течении 20мкс, затем опять 1 на 30мкс и 
в конце - логический 0 на 100микросекунд

Начнем с того, что войдем в режим редактирования последовательности (пусть
это будет последовательность номер 1)

  esp32#>sequence 1
  esp32-seq#>

Тут надо заметить, что продолжительность импульсов в espshell задается в 
"тиках". Чему равен 1 тик? Длина тика задается командой tick. Зададим длину 
тика в 1 микросекунду:

  esp32#>sequence 1
  esp32-seq#>tick 1

Параметр команды "tick" это число с плавающей точкой, в диапазоне от 0.0125
до 3.2 микросекунды.

Теперь зададим саму последовательность - один из способов это сделать это
использовать команду "levels":


  esp32#>sequence 1
  esp32-seq#>tick 1
  esp32-seq#>levels 1/10 0/20 1/30 0/100


Команда "levels" принимает на вход список уровней (0 или 1) и их 
продолжительность, измеренная в "тиках". Мы выбрали длину тика равной 1 
микросекунде, поэтому длина в "тиках" это то же самое, что длина в микросекундах,
Уровень может принимать значения 0 или 1, в то время как длительность не может 
превышать 32767 тиков. Учитывая, что максимальный размер тика может быть 3.2 
микросекунды, получаем, что максимальная длительность одного такого уровня не 
может превышать 105 миллисекунд.  Ниже будет показано, как задавать длины 
импульсов любой продолжительности.

Ок, последовательность задана, теперь нужно "проиграть" ее на пине 2:

  esp32#>sequence 1
  esp32-seq#>tick 1
  esp32-seq#>levels 1/10 0/20 1/30 0/100
  esp32-seq#>exit
  esp32#>pin 2 seq 1

Выходим из режима конфигурирования последовательностей с помощью команды "exit"
и используем команду "pin" для посылки последовательности.
А можно послать ту же самую последовательность 4 раза, например, заменив 
последнюю команду "pin" на такую:

  esp32#>pin 2 seq 1 seq 1 seq 1 seq 1

  Подробнее синтаксис команды "pin" и ее возможности описаны в 
  файле "docs/ru_RU/Pin_commands.txt"


Помимо задания каждой 1 и каждого 0 вручную, указывая длительность каждого
уровня можно описать вашу логическую единицу и логический ноль, а затем задать
строку нулей и единиц, которая будет преобразована в пары уровень/длительность
автоматически.

Решим ту же самую задачу, что и выше, этим новым "битовым" способом. Итак,
последовательность, которую нам надо послеть это:

"1 на 10мкс, 0 -  20мкс, 1 - 30мкс, 0 -  100мкс"

Для начала, определим, что такое ноль и что такое один - для этого в espshell 
есть команды "one" и "zero". Сами биты на отсылку задаются командой "bits". 
Надо заметить, что команда "bits" перезапишет ранее установленные "levels", а 
команда "levels" в свою очередь перезапишет сделанное командой "bits".

  esp32#>sequence 0
  esp32-seq#>tick 1
  esp32-seq#>one 1/10
  esp32-seq#>zero 0/10
  esp32-seq#>bits 1001110000000000

Мы видим новые три команды: мы задаем 1 как высокий уровень на 10 тиков, мы 
задаем 0 как низкий уровень на 10 тиков. Длинну тика мы оставляем равной 1 
микросекунде,как и в примере с "levels" .

Строка "bits" задает нашу последовательность с нужными таймингами :
 1 длится 10 мкс, 00 длится 20мкс, 111 - 30мкс и так далее.
Выполнив команду "show" можно посмотреть, какие levels сгенерировал espshell
                                                              |
                                                              |
                                                              |
  esp32-seq#>show                                             |
  %                                                           |
  % Sequence #0:                                              |
  % Resolution : 1.0000uS  (Frequency: 1000000 Hz)            |
  % Levels are :                                              |
  % 1/10, 0/10, 0/10, 1/10, 1/10, 1/10 ....              <----+


Команда "show" может быть исполнена и из основного дерева команд - там она 
называется "show seq" с аргументом-номером последовательности

Команды "one" и "zero"на самом деле позволяют задавать не просто уровень 
логического нуля или единицы, а полноценный импульс (перепад): например, 
можно описать логический 0 как HIGH 100мкс,LOW 50мкс , а единицу - как 
HIGH 50мкс, LOW 150мкс. Да, так тоже можно. Подобная схема кодирования битов
используются в пультах IR.

Для задания такого импульса используются все те же самые команды "one" и 
"zero" но с двумя аргументами. Так, выше приведенный пример будет задан 
так:

  esp32-seq#>one 1/50 0/150
  esp32-seq#>zero 1/100 0/50
  esp32-seq#>bits 100111
  esp32-seq#>show
  %
  % Sequence #0:
  % Resolution : 1.0000uS  (Frequency: 1000000 Hz)
  % Levels are :
  % 1/150, 0/50, 1/50, 0/150, 1/50, 0/150, 1/150, 0/50,
  % 1/150, 0/50, 1/150, 0/50,
  % Total: 12 levels, duration: 1200 ticks, (~1200 uS)


Ок, пример попроще и попрактичнее - помигать светодиодом, примерно раз в 
секунду.

Тик мы выберем максимальной продолжительности, 3.2 микросекунды, зададим 
наши 0 и 1 так же макимальной длины в 32767 тиков:

  esp32-seq#>tick 3.2
  esp32-seq#>one 1/32767
  esp32-seq#>zero 0/32767
  esp32-seq#>bits 11111111000000001111111100000000

  Выходим из режим конфигурирования последовательностей выполнив команду "exit"
  и мигаем светодиодиком (в данном примере светодиод находится на пине 2)

  esp32-seq#>ex
  esp32#>pin 2 seq 1
  % Sending sequence 0 over GPIO 2
  esp32#>


Команда "modulation" позволяет промодулировать генерируемые импульсы определенной
частотой и скважностью. Данный тип модуляции используется, например, протоколом 
NEC для пультов управления. Команда принимает до 3-х параметров: частоту модуляции 
в герцах, скважность (duty) в процентах (от 0 до 1, 0.6 это 60% duty) и указание 
на то, какие биты модулировать - нули или единицы. Параметр частота является 
обязательным, вторые два - опциональными. Если не указаны, то используется duty 
50%, модулируются единицы.

Выполнив команду "modulation ?" можно посмотреть на примеры ее использования.

Команда "eot" задает состояние пина (HIGH или LOW) по окончании передачи. 
Значение по умолчанию - LOW
