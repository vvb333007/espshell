Фаловые системы ESP32
---------------------

По состоянию на конец 2024 года в числе официально поддерживаемых (с разной 
степенью оффициальности) находятся три файловые системы:

 1. SPIFFS, так называемая [SPI] [F]lash [F]ile [S]ystem, совсем простенькая
    файловая система, не поддерживающая каталоги. Впрочем, некоторая симуляция 
    каталогов все же есть: можно, например, создать файл с именем 
    "/some/file/name.txt" который "как бы"  находится в кталогах, но на самом
    деле, это просто такое имя файла - со слешами.

 2. FAT. Старый добрый FAT (12/16/ex, все расширения). В отличии от остальных
    файловых систем использует библиотеку wear_levelling, призванную уменьшать
    неравномерность износа карты памяти

 3. LittleFS (официальная страничка: https://github.com/littlefs-project/littlefs, 
    порт для ESP32 делается другими ребятами. 
    Из достоинств - написана специально для flash памяти, усредняет нагрузку 
    на флеш и, по заявлению авторов, устойчива к пропаданию питания.

Все три вышеозначенные файловые системы поддерживаются оболочкой.

В каталоге "extra/" лежит файлик partitions.csv: если такой файлик положить
в каталог к своему скетчу, то Arduino IDE создаст разделы во флеш памяти
согласно данным из этого файла. В файлике создаются все три файловые системы:
в обычной жизни достаточно одной. Сам ESPShell можно скомпилировать с выборочной
поддержкой файловых систем, чтобы уменьшить размер занимаемой памяти: для этого
нужно установить в нулевое значение один или несколько параметров

 WITH_SPIFFS
 WITH_FAT
 WITH_LITTLEFS

Сделать это можно либо в "extra/espshell.h" либо непосредственно в espshell.c,
(поищите словосочетание TAG:settings для ориентира)


НАЗНАЧЕНИЕ
----------

Основное предназначение фалового менеджера в ESPShell это создание,удаление,
копирование и переименовывание фалов и каталогов, которые использует скетч:
файлы настроек, базы данных, логи, веб страницы и тому подобное.

Файловый менеджер позволяет просматривать бинарные и текстовые файлы, выводя 
их или на экран или отсылаяв один из UART портов. Один из сценарие использования
широко распостраненного LTE модема компании Simcom SIM7600E подразумевает 
использование файловой системы модема: у него на борту 64 гигабайта памяти, 
доступных для записи туда файлов для последубщей отсылки по internet. Этот
модем, являясь UART устройством, принимает файлы по UART интерфейсу, как раз
в том виде, в котором ESPShell умеет их посылать. 
Так совпало.

Для текстовых файлов так же доступны операции "insert", "append" и "delete":
вставка и удаление строк, дописывание строк в конец файла: для небольших 
правок "по месту"


КОМАНДЫ
-------

  ВАЖНЫЕ МОМЕНТЫ: 
    1. Звездочки вместо пробелов: если есть нужда работать с именами файлов и 
       каталогов, где есть пробелы, то следует использовать звездочку (*) вместо 
       пробелов. Оболочка преобразовывает все звездочки в пробелы.

    2. Автозавершения имен файлов или каталогов по нажатию на <TAB> нет. Реализация 
       этого утяжелит и без того тяжелый код оболочки. Все же сценарии работы с 
       фалами на обычной Linux системе и ESP32 различны: на ESP32 файловые операции 
       обычно не часты и просты

    3. path wildcards (звездочки, знаки вопроса и т.п.) не поддерживаются. Если нужно
       удалить сто фалов img1, img2, img100 , то придется сто раз вызывать команду "rm"
       (если только эти файлы не в каталоге, который можно удалить целиком)


Войти в режим файлового менеджера можно введя команду "files" (выйти можно командой
"exit" или нажатием Ctrl+Z в окне терминала):

  esp32#>files
  % Entering filesystem mode. Ctrl+Z or "exit" to return
  % Hint: Main commands are still avaiable (but not visible in "?" command list)
  esp32#(/)>

В строке приглашения теперь появился символ "/" - это текущий рабочий каталог.
В этом каталоге можно создавать только точки монтирования других файловых систем. Каталог
этот - виртуальный, его нельзя отформатировать или создать в нем файл. Каталоги в нем
создаются командой "mount"


"mount"
"mount LABEL [/PATH]"
---------------------
Команда "mount" имеет две функции: вывести на экран таблицу разделов диска с указанием
смонированных систем и, собственно, монтирование систем. Команда "mount" без параметров
выводит на экран таблицу разделов:

  esp32#(/)>mount
  % Disk partition |M|File system| Size on |    Mounted on    |Capacity |  Free
  %    label       |?|   type    |  flash  |                  |  total  |  space
  % ---------------+-+-----------+---------+------------------+---------+---------
  %             nvs| | NVStorage |     20K |                  |         |
  %         otadata| |  OTA data |      8K |                  |         |
  %         wwwroot|+| FAT/exFAT |    960K |                  |         |
  %            pr0n|+|    SPIFFS |    480K |                  |         |
  %            logs|+|  LittleFS |    480K |                  |         |
  %        coredump| | Core dump |     64K |                  |         |
  %
  % 3 mountable partitions found. (+) - mountable partition
  esp32#(/)>

Плюсики в колонке "M?" означают, что фаловую систему, в принципе, можно смонтировать.

Для монирования используем всю ту же самую команду "mount":

  esp32#(/)>mount wwwroot
  %  FAT/exFAT  on partition "wwwroot" is mounted under "/wwwroot"
  esp32#(/)>

Или, используя сокращенную форму записи:

  esp32#(/)>m l
  %   LittleFS  on partition "logs" is mounted under "/logs"
  esp32#(/)>

По умолчанию, ESPShell монтирует разделы в каталоги, имена которых он определяет сам,
строя их из названия раздела на диске и слеша. Поэтому команда "mount logs" смонитрует
раздел "logs" в каталог "/logs".

Если необходимо изменить точку монтирования по умолчанию, то ее можно указать вторым 
аргументом команды "mount". В примере ниже файловая систем монтируется в каталог с 
названием /my/fs

  esp32#(/)>m p /my/fs/
  %     SPIFFS  on partition "pr0n" is mounted under "/my/fs"
  esp32#(/)>

Введем еще раз команду "mount" без параметров, чтобы посмотреть как теперь выглядит
таблица разделов:

  % Disk partition |M|File system| Size on |    Mounted on    |Capacity |  Free
  %    label       |?|   type    |  flash  |                  |  total  |  space
  % ---------------+-+-----------+---------+------------------+---------+---------
  %             nvs| | NVStorage |     20K |                  |         |
  %         otadata| |  OTA data |      8K |                  |         |
  %         wwwroot|+| FAT/exFAT |    960K |         /wwwroot |    920K |    884K
  %            pr0n|+|    SPIFFS |    480K |           /my/fs |    434K |    434K
  %            logs|+|  LittleFS |    480K |            /logs |    480K |    464K
  %        coredump| | Core dump |     64K |                  |         |
  %
  % 3 mountable partitions found. (+) - mountable partition
  esp32#(/)>

Напртив смонтированных разделов появилась дополнительная информация: точка 
монтирования, общая емкость и размер свободного места.



"umount"
"unmount"
"umount /PATH"
"unmount /PATH"
---------------

Размонтировать фаловую систему можно двумя способами:
командой "unmount" (или "umount", если вы фанат linux) с указанием точки монтирования:

  esp32#(/)>umount /www
  % Unmounted  FAT/exFAT  partition "/wwwroot"
  esp32#(/)>

Или, находясь в каком-либо каталоге файловой системы выполнить команду "unmount"
без параметров. В этом случае оболочка сама попытается определить точку монтирования:


  esp32#(/wwwroot/index/)>unmount
  % Unmounted  FAT/exFAT  partition "/wwwroot"
  esp32#(/)>



"format [LABEL]"
----------------
Форматирование файловой системы. Если метка раздела не указана, то оболочка будет пытаться 
выяснить, о каком разделе идет речь из текущего рабочего каталога:

  esp32#(/wwwroot/index/)>format
  % Formatting partition "wwwroot", file system type is " FAT/exFAT "
  % done
  esp32#(/wwwroot/)>

После форматирования рабьочий каталог устанавливается в значение точки монтирования. Тип файловой
системы задается в файле partitions.csv и не может быть изменен в рантайме.







"ls [PATH]"
-----------

Листинг каталога. У команды может быть один опциональный параметр - путь до каталога, листинг которого
мы хотим получить. Если параметр не указан, то используется текущий каталог:

  esp32#(/wwwroot/)>ls
  %    Size        Modified          *  Name
  %               -- level up --    DIR [..]
  %       171  1980-01-01 01:43:26  DIR [index]
  %       146  1980-01-01 01:43:26  DIR [logs]
  %         0  1980-01-01 01:43:26  DIR [uphp]
  %         0  1980-01-01 01:43:26  DIR [tmp]
  %        57  1980-01-01 01:46:18      index.html
  %
  % 4 directories, 1 file, 374 bytes
  esp32#(/wwwroot/)>

Размер файлов и каталогов - в байтах, размер каталога включает в себя размер всех объектов, находящихся
в нем. Сортировки имен файлов\каталогов не предусмотрено. Вместо этого имена выводятся в том порядке, в
котором они были созданы.


Пример: посмотреть, что там, внутри "/wwwroot/index/"

  esp32#(/)>ls wwwroot/index
  %    Size        Modified          *  Name
  %               -- level up --    DIR [..]
  %        57  1980-01-01 01:45:00      index.php
  %        57  1980-01-01 01:45:16      index_old.php
  %        57  1980-01-01 01:45:26      index_html
  %
  % 0 directories, 3 files, 171 bytes
  esp32#(/)>


ВАЖНО: по умолчанию, команда "ls"  отображает размеры файлов и каталогов. Если каталогов много и у них
большая вложенность, то работа оболочки может стать нестабильной: может тормозить или вообще повиснуть
из-за нехватки памяти, если вложенность сильно большая. Если вы испытываете проблемы с отображением
размеров каталогов, то выключите его командой "var ls_show_dir_size 0". Эта команда устанавливает 
внутреннюю переменную оболочки в значение false. (Подробнее - см. файл "docs/ru_RU/Commands.txt", 
описание команды "var")


"cd [PATH|..]"
--------------

Смена каталога, стандартная всем известная команда "cd".

Оболочка понимает три различных написания этой команды

  1. "cd" : команда без параметров. Каталог меняется на корневой каталог для данной фаловой системы,
            т.е. меняется на точку монтирования:

            esp32#(/wwwroot/1/2/)>cd
            esp32#(/wwwroot/)>

  2. "cd .." : команда с одним аргументом, двоеточием. Переход в каталог уровнем выше.
      Неприятным моментом является тот факт, что написать, например, "cd ../../" нельзя,
      оболочка не поймет. Вместо этого следует дважды исполнить команду "cd .."

         
  3. "cd PATH" : один аргумент, путь до какого-либо существующего каталога. Значение текущей
                 рабочей директории будет установлено согласно PATH

       esp32#(/wwwroot/)>cd test_dir/dir2
       esp32#(/wwwroot/test_dir/dir2/)>cd
       esp32#(/wwwroot/)>cd ..
       esp32#(/)>
      

"rm PATH"
---------
Удаление файлов и каталогов, без подтверждений.


  esp32#(/)>ls wwwroot/test_dir
  % Size/Used      Modified          *  Name
  %               -- level up --    DIR [..]
  %            1980-01-01 01:00:24  DIR [dir2]
  %         4  1980-01-01 01:16:20      test.cfg
  %
  % 1 directory, 1 file, 4 bytes


  esp32#(/)>rm wwwroot/test_dir
  % Directory removed: "/wwwroot/test_dir/dir2/"
  % File removed: "/wwwroot/test_dir/test.cfg"
  % Directory removed: "/wwwroot/test_dir/"
  % 3 files/directories were deleted
  esp32#(/)>


"write PATH [TEXT]"
-------------------
Создает новый файл PATH, и записывает в него TEXT. Если файл уже существовал, то он перезапишется.
В файл добавляется только тот текст, который указал пользователь: никакие дополнительные символы 
(например, символ переноса строки "\n") не добавляются. В этом состоит отличие от комманды "insert",
которая автоматически добавляет символ "\n" к тому, что ввел пользователь.

Параметр TEXT здесь (как и в других командах, где аргументом указан "TEXT", например команда файлового
менеджера "insert" или команда uart интерфейса "write") подразумевает любой текст, состоящий из 
печатных символов, знаков пробел, произвольных байтов, общепринятых в языке Си escape-последовательностей,
таких как "\n","\r","\t","\b","\e", или даже произвольных байтов, в шеснадцатеричном виде: "\XY", где X и Y
- шеснадцатиричные числа:

  esp32#(/wwwroot/)>write test.txt Hello world!\nNew\20line\nThis is \61 test file!\n
  % 46 bytes written to /wwwroot/test.txt
  esp32#(/wwwroot/)>

Пример выше создает файл "test.txt" с вот таким содержимым:

  Hello world!
  New line   
  This is a test file!


  *("\20" - шеснадцатиричный код пробела, 61 - буква "a")

Если текст не задан, т.е. команда запущена с одним аргументом, именем файла, то тогда в файл будет 
записан один ндинственный байт: символ перевода строки. Если путь содержал каталоги, то они будут
созданы


"append PATH TEXT"
------------------
Добавляет произвольный текст\байты TEXT в конец сцществующего файла PATH. Аргументы команды в точности
такие же, как и у команды "write"


"insert PATH LINE_NUM [TEXT]"
----------------------------
Вставляет строчку (строки и\или байты) в файл текстовый PATH, перед строкой с номером LINE_NUM. Нумерация
строк начинается с еденицы, поэтому, тобы вставить строчку в начало файла, следует написать:

  esp32#(/wwwroot/)>insert test.txt 2 A couple of lines\ninserted by "insert" command
  % Line 2 inserted
  esp32#(/wwwroot/)>  

Содержимое файла (который мы создали командой "write", в соответствующем примере выше) 

  Hello world!
  A couple of lines
  inserted by "insert" command
  New line   
  This is a test file!

Команда "insert" всегда добавляет символ \n в конец пользовательского текста. Если параметр TEXT опущен
то будет вставлена пустая строка (строка состоящая из одного символа \n)


"delete PATH LINE_NUM [COUNT]"
------------------------------
Удаляет строчку (строчки) из файла PATH. Аргументы команды: LINE_NUM - строчка, с которой слкдует начать удаление,
COUNT - сколько строк удалить (если не задано, то всегда значение будет равно единице). Узнать номера строк
произвольного файла можно используя команду "cat -n" (см ниже описание команды "cat")

  esp32#(/wwwroot/)>del test.txt 2 3
  % Line 2 deleted
  % Line 3 deleted
  % Line 4 deleted
  esp32#(/wwwroot/)>

Содержимое файла (после примера из команды "append")

  Hello world!
  This is a test file!

Если аргумент COUNT выходит за границы (т.е. затребовано для удаления бОльшее количество строк, чем есть на самом деле),
то ничего страшного: например, чтобы удалить содержимое файла, начиная со строчки 100 и до конца, можно использовать
команду "del test.txt 100 9999" - задавая число COUNT заведомо больше разумного\реального предела мы поудаляем все строчки
до конца. Ну, если, конечно, в вашем файле не больше 9999 строчек.


"mkdir PATH1 PATH2 ... PATHn"
-----------------------------
Насоздавать катологов. Пробел в данном случае - разделитель имен каталогов. Чтобы задать путь, в котором содержатся пробелы,
нужно просто вместо пробелов вводить звездочки (*): звездочки будут преобразованы в пробелы оболочкой автоматически


  esp32#(/wwwroot/)>mkdir dir1 dir_two another_dir Program*Files
  % Processing multiple paths.
  % Not what you want? Use asteriks (*) instead of spaces in the path
  esp32#(/wwwroot/)>


Выведем на экран содержимое текущей директории (команда "ls" без параметров):

  esp32#(/wwwroot/)>ls
  %    Size        Modified          *  Name
  %               -- level up --    DIR [..]
  %        34  1980-01-01 01:26:28      test.txt
  %         0  1980-01-01 01:33:38  DIR [dir1]                <-+-- свежесозданные
  %         0  1980-01-01 01:33:38  DIR [dir_two]             <-+     каталожки
  %         0  1980-01-01 01:33:38  DIR [another_dir]         <-+
  %         0  1980-01-01 01:33:38  DIR [Program Files]       <-+
  %
  % 4 directories, 1 file, 34 bytes
  esp32#(/wwwroot/)>

При указании путей, содержащих вложенные каталоги: "mkdir some/dir/path1" будут созданы все каталоги, если их не было

"touch PATH1 PATH2 ... PATHn"
-----------------------------

Как "mkdir" но только для файлов :). Создает новые пустые файлы или, у существующих, обновляет время
доступа к файлу (modification timestamp). Если путь содержит каталоги, то каталоги будут автоматически созданы


"cat [-n|-b] PATH [LINE_NUM [COUNT]] [uart NUM]"
------------------------------------------------

Команда в некотором смысле пытается копировать собой команду Linux "cat", с той лишь разницей, что
в Linux команда "cat" может использоваться для объеденения нескольких файлов. В RSPShell же, команда 
cat всегда работает с одним файлом

Необязательные опции "-n" и "-b", как и в Linux cat, включаютвывод номеров строк для текстовых файлов
или, наоборот, сообщают оболочке, что файл не текстовый а бинарный

Необязательные параметры LINE_NUM и COUNT задают регион для отображения: начиная с какой строчки начинать
вывод файла, и сколько строчек отобразить. Для бинарных файлов LINE_NUM на самом деле не номер строчки,
а смещение от начала файла, а COUNT - количество байт для отображения. Если параметр COUNT опущен, то это 
означает ("до конца файла")

При указании ключевого слова "uart" после имени файла, команда "cat" перенаправит весь вывод в указанный UART 
интерфейс. При задании ключа "-b", файл будет отослан в UART как есть, байт за байтом. Это можно использовать,
например, для записи файлов во внутреннюю фаловую систему LTE модема SIMCOM SIM7600E

Простейший случай: вывести на  экран содержимое текстового файла "index.html" :

  esp32#(/wwwroot/)>cat index.html
  <html>
  <head></head>
  <body>
  Hey! This line was inserted!
  And this line also!
  Hello World!
  </body>
  </html>

  esp32#(/wwwroot/)>

Выведем содержимое того же файла, две строки, начиная с четвертой:

  esp32#(/wwwroot/)>cat -n index.html 4 2
     4: Hey! This line was inserted!
     5: And this line also!
  esp32#(/wwwroot/)>

Если мы добавим опцию "-n", то команда "cat" будет добавлять номера строк к выводимому 
содержимому текстовых файлов. Эту опцию можно использовать, чтобы узнать номера строк для 
команд "insert" и "delete". Как бы то ни было, нумерация строк начинается с единицы

Если же вместо "-n" мы воспользуемся опцией "-b" (эти опции взаимоисключающие), то вывод 
будет производится в табличной форме. Эта команда используется для отображения бинарных 
файлов. При просмотре бинарных файлов аргументы LINE_NUM и COUNT обозначают не номер и 
количество строк, а смещение (в байтах) от начала файла. Аргумент COUNT в данном случае 
задает количество байт для отображения:

  esp32#(/wwwroot/)>cat -b index.html
         0  1  2  3   4  5  6  7   8  9  A  B   C  D  E  F  |0123456789ABCDEF
  ----------------------------------------------------------+----------------
  0000: 3c 68 74 6d  6c 3e 0a 3c  68 65 61 64  3e 3c 2f 68  |<html>.<head></h
  0010: 65 61 64 3e  0a 3c 62 6f  64 79 3e 0a  48 65 79 21  |ead>.<body>.Hey!
  0020: 20 54 68 69  73 20 6c 69  6e 65 20 77  61 73 20 69  | This line was i
  0030: 6e 73 65 72  74 65 64 21  0a 41 6e 64  20 74 68 69  |nserted!.And thi
  0040: 73 20 6c 69  6e 65 20 61  6c 73 6f 21  0a 48 65 6c  |s line also!.Hel
  0050: 6c 6f 20 57  6f 72 6c 64  21 0a 0a 0a  3c 2f 62 6f  |lo World!...</bo
  0060: 64 79 3e 0a  3c 2f 68 74  6d 6c 3e 0a  0a           |dy>.</html>..
  % EOF (109 bytes)
  esp32#(/wwwroot/)>

Внимание: при отсылке файла через UART интерфейс следует указывать опцию "-b":
в таком случае файл будет отослан в виде файла (байт за байтом), а не в виде 
таблички.


"cp" и "mv"
-----------

TBD
