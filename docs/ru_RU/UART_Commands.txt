ESP32Shell for the Arduino Framework by vvb333007 <vvb@nym.hush.com>

UART, общие сведения
--------------------

У ESP32 на борту имеется 3 UARTа, (в зависимости от модели, у ESP32S2 например их два)
UART0 используется для ввода\вывода и в Arduino скрывается за глобальным экземпляром
класса "class HardwareSerial Serial". Тот самый, который обрабатывает ваши Serial.print()

На отладочных платах с включенным режимом USB-OTG (например, на базе ESP32-S3) класс Serial
не имеет отношения к UART и обрабатывается кодом USB-CDC. Такие отладочные платы espshell 
не поддерживает: ожидается, что uart0 является устройством ввода\вывода по умолчанию.

При старте скетча, до выполнения setup() и loop() запускается espshell; запускается и 
ждет,пока будет проинициализирован uart0 и после этого начинает свою работу. 
Хотя ESPShell по умолчанию запускается на uart0 (использует uart0 для ввода\вывода)
это его поведение может быть изменено - в файле espshell.c можно изменить значение

  #define USE_UART UART_NUM_0 

для задания любого номера UART


Фактически, espshell ждет, после запуска, момента инициализации Serial:

  void setup() {
  ....
    Serial.begin(115200);
  ....
  }

Как только ESPShell понимает, что UUART0 стал доступен, запускается интерпретатор
команд.


Доступ к UART из ESPShell: инициализация, чтение, запись, бриджинг
------------------------------------------------------------------

Команды для работы с интерфейсом UART находятся в специальном подразделе, доступ
к которому начинается с выбора uarta командой "uart X", где X - это номер UART, от
0 до 3 (или двух, в зависимости от модели процессора). После успешного выполнения
команды мы попадаем в раздел с командами uart, о чем нам говорит изменившаяся строка
приглашения (промпт):

  esp32#>ua 1
  esp32-uart#>

Список доступных команд может быть получен выполнением команды "?":

  esp32-uart#>?
  % Enter "? command" to get details about the command.
  % List of available commands:
  %
  % "?"        : Show the list of available commands
  % "up"       : Initialize uart (pins/speed)
  % "baud"     : Set baudrate
  % "down"     : Shutdown
  % "read"     : Read data from UART
  % "tap"      : Talk to UARTs device
  % "write"    : Send bytes over this UART
  % "exit"     : Exit
  esp32-uart#>

Команда "exit" (или, что тоже самое, Ctrl+Z) позволяет выйти из режима UART в 
корневую директорию команд.

ВАЖНО: несмотря на то, что в списке выше отсутствуют команды из корневой директории 
команд, эти команды можно исполнять. Например, находясь в режиме конфигурации UART
можно выполнить команду "pin" или, к примеру, "uptime"

Не считая команд "?" и "exit" у нас есть 6 команд для работы с UART, позволяющие
инициализировать и деинициализировать интерфейс, посылать и получать данные,
работать в режиме моста, когда все, что поступает в uart порт тут же выводится 
на экран, а все, что пользователь набирает на клавиатуре тут же отсылается
в uart. Таким образом, например, можно "зайти" на GSM модем подключенный к uart
интерфейсу ESP32 и исполнять на нем AT команды. 

Все команды, за исключением "?","exit" и "up" требуют того, чтобы интерфейс был
проинициализирован: заданы пины RX и TX, установлена скорость порта.

Инициализация осуществляется командой "up", которая принимает три параметра:
номера пинов RX, TX и скорость в бодах. Остальные параметры порта заданы жестко
и не могут быть изменены без изменения исходного кода espshell.c: 

  8бит, без четности, 1 стоп бит

Проинициализируем интерфейс uart1 на пинах 21 и 22 на скорости 115200. К этому
порту у нас подключен LTE модем SIMCOM Sim7600E:

  esp32#>uart 1
  esp32-uart#>up 21 22 115200
  esp32-uart#>

Если все произошло успешно, никаких сообщений не появится.

"down" - Команда прямо противоположная "up" : деинициализирует интерфейс, 
         высвобождает ресурсы (пины, память, прерывания) забранные драйвером
         при инициализации. Если интерфейс не был проинициализирован, то эта
         команда не делает ничего.

         Обратите внимание на то, что запущенный скетч может что-то читать
         из порта в тот момент, когда вы его деинициализируете. Это может
         вызвать всякого рода глюки, поэтому имеет смысл при переконфигурировании
         uart порта "на ходу", приостановить работающий скетч командой "suspend"


"baud" - Поменять скорость на порте. Если меняете на порте 0, то не забудьте
         поменять скорость и в Arduino IDE Serial Monitor (или TeraTerm/PuTTY)

"read" - Прочитать данные из UART. Будет считано столько байт, сколько было получено
         на момент исполнения этой команды. Прочитанная строка выводится на экран:
         для непечатных символов выводится их шеснадцатиричный код (в виде \xAB), 
         остальные символы выводятся без изменений


"write"- Посылка данных в UART. Это могут быть строки, разделенные пробелами, 
         содержащие печатные символы. Для непечатных символов предусмотрен ввод
         escape-последовательностей.

         Уspshell распознает следующие последовательности:

          \n           <LF>
          \r           <CR>
          \t           <TAB>
          \\           \
          \XY          Символ с шеснадцатеричным кодом XY

         Идущие подряд пробелы будут переданы как 1 пробел. Чтобы такого не 
         происходило, пробелы можно закодировать как \20 - это шеснадцатеричный 
         код 'пробел'.
         
         Одинаковые команды:
          write A B
          write A       B

         Правильный способ послать несколько пробелов:
          write A\20\20\20\20\20\20B


"tap" -  Организует мост между выбранным UART и UART на котором работает espshell.
         Используется, чтобы "говорить"  с устройством, подключенным к порту uart
         напрямую, без использования команд "read" и "write". Это бывает полезно
         при отладке модемов, GSM чипов с NMEA-интерфейсом и пр. Пример использования
         этой команды будет ниже.



ПРИМЕРЫ
-------
 
  Пример 1. К ESP32, пинам 21 и 22 присоеденен LTE модем SIM7600E. 
            Посылаем команды, получаем ответы (команды "read"/"write")

  esp32#>uart 2
  esp32-uart#>up 21 22 115200
  esp32-uart#>write \ff\ff\CC\r\n
  5 bytes sent 
  esp32-uart#>write ATI\r\n
  5 bytes sent
  esp32-uart#>read
  ATI
  Manufacturer: SIMCOM INCORPORATED
  Model: SIMCOM_SIM7600E
  Revision: SIM7600M21-A_V1.1
  IMEI: 861005075537800
  +GCAP: +CGSM
 
  OK
  
  137 bytes read
  esp32#>


  Пример 2. К ESP32, пинам 21 и 22 присоеденен LTE модем SIM7600E. 
            Посылаем команды, получаем ответы (команда "tap")


 "tap" создает мост между пользователем и устройством, подключенным к
  выбранному интерфейсу uart: все, что вводит пользователь отсылается в
  устройство, а все, что выводит устройство - поступает пользователю.

  Чтобы выйти из этого режима, следует нажать CTRL+C, что, например,
  невозможно сделать в Arduino IDE Serial Monitor. Похожим образом, например,
  AT команды отсылки SMS будут ожидать нажатия CTRL+Z, что опять же невозможно
  сделать из Serial Monitor. Использование софта, такого как "PuTTY", "TeraTerm",
  или даже "cu" на Linux решает эту проблему.

  Вот так может выглядеть посылка команды "ATI" на модем с использованием "tap"

   esp32#>uart 1
   esp32-uart#>up 21 22 115200
   esp32-uart#>tap
   Tapping to UART1, CTRL+C to exit
   ATI                                  <----- ввод пользователя
   Manufacturer: SIMCOM INCORPORATED    <----- ответ модема
   Model: SIMCOM_SIM7600E
   Revision: SIM7600M21-A_V1.1
   IMEI: 861005075537800
   +GCAP: +CGSM
  
   OK
   
   Exit                                 <------ пользователь нажал Ctrl+C
   esp32#>

Вкратце, это все по uart'ам. Используйте "?" перед командой, чтобы получить
описание и примеры использования каждой конуретной команды

Удачи!


