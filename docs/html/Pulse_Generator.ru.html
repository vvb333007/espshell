<!DOCTYPE html>
<html lang="ru">
<head>
  <title>ESPShell : Генератор последовательностей импульсов</title>
  <link rel="stylesheet" href="espshell.css">
</head>
<body>
<p align=center><a href="index.ru.html"><img src="i/espshell_logo.jpg" alt="ESPShell for Arduino :: Генератор сигналов" width="70%" height="70%" /></a></p>
<h3 align=center><a href="Pulse_Generator.ru.html">[ На русском ]</a>&nbsp;&harr;&nbsp;<a href="Pulse_Generator.html">[ English ]</a></h3>
<p>
  <ul>
    <li><a href="#pg">Генерация импульсов</a></li>
    <li><a href="#basic">Основные понятия: "тик", "уровень" и "импульс"</a></li>
    <li><a href="#send">Отправка импульсных последовательностей</a></li>
    <li><a href="#bits">Битовые строки</a></li>
    <li><a href="#mod">Модуляция и Окончание Передачи</a></li>
    <li><a href="#show">Отображение информации</a></li>
    <li><a href="#examples">Примеры</a></li>
  </ul>
</p>

<p><h2 id=pg><a href="#top">&#8686;</a>ГЕНЕРАЦИЯ ИМПУЛЬСОВ</h2></p>

<p>
ESP32 имеет специальный периферийный модуль генерации импульсных последовательностей, называемый RMT, 
основное назначение которого — создание произвольных сигналов с довольно высокой разрешающей способностью — до 0.0125 микросекунды (минимальная ширина импульса). 
Если вам "вручную" нужно создать какой-то цифровой сигнал, то RMT это то, что нужно.
</p>

<p>
Может использоваться как генератор сигналов общего назначения или для генерации ИК-сигналов дистанционного управления. Для второго случая предусмотрена так же модуляция нулей или единиц в вашем сконструированном сигнале.
</p>

<p><h2 id=basic><a href="#top">&#8686;</a>ОСНОВНЫЕ ПОНЯТИЯ: "ТИК", "УРОВЕНЬ" И "ИМПУЛЬС"</h2></p>

<p>
Генерация импульсов осуществляется с помощью команд "<b>sequence</b> <i>SEQ_ID</i>" и "<b>pin</b> <i>PIN</i> <b>seq</b> <i>SEQ_ID</i>":
первая команда задает <i>последовательность импульсов</i>, а вторая — запускает её на исполнение. Номер последовательности (<i>SEQ_ID</i>) должен быть от 0 до 9, 
то есть можно создать и использовать до 10 различных последовательностей. 
Если требуется больше, можно <a href="Customizing.ru.html">изменить макрос SEQUENCE_NUM</a> в файле <b>espshell.h</b>.
</p>

<p>
Перед тем как перейти к описанию команд и примеров, рассмотрим основные термины:
</p>

<p>
<ul>
  <li><b>Уровень</b> — это логический "0" или "1", то есть просто <i>уровень напряжения</i>. Последовательность может состоять из <i>уровней</i> или <i>импульсов</i>.</li>
  <li><b>Импульс</b> — это два последовательных уровня: "лог.1 в течение X нс, затем лог.0 в течение Y нс". Импульсы используются в ИК-протоколах; например, 
манчестерское кодирование можно представить как последовательность <i>импульсов</i>.
 
В отличие от <i>уровней</i>, импульсы могут быть <i>модулированы</i> (на лог.1 или лог.0), что позволяет использовать их, например, в ИК-пультах (протокол NEC).</li>
  <li><b>Тик</b> — это единица времени. Все интервалы в последовательности измеряются в "тиках". Тик можно установить в диапазоне от 0.0125 мкс до 3.2 мкс. 
По умолчанию тик равен 1 мкс.</li>
</ul>
</p>

<p>
Рассмотрим простую задачу: нужно сгенерировать несколько импульсов на выводе pin2 следующим образом:
</p>

<p>
"Установить pin2 в HIGH на 10 мкс, затем в LOW на 20 мкс, снова HIGH на 30 мкс, и наконец LOW на 100 мкс"
</p>

<p>
Начинаем с режима конфигурации последовательности:
</p>

<pre>
  esp32#>sequence 0
  esp32-seq0>
</pre>

<p>
Команда "<b>sequence 0</b>" создаёт пустую последовательность с номером 0 и переключает оболочку в режим конфигурации, что видно по изменению приглашения на "<b>esp32-seq0></b>". 
Чтобы выйти из этого режима, используйте "<b>exit</b>" или нажмите <kbd>Ctrl+Z</kbd>.
</p>

<p>
Сначала установим <i>разрешение</i> последовательности, то есть "длину тика".
</p>

<p>
Выберем тик длиной 1 мкс:
</p>

<pre>
  esp32#>sequence 0
  esp32-seq0>tick 1
</pre>

<p>
По умолчанию тик уже равен 1 мкс, поэтому команду "tick 1" можно опустить.
</p>

<p>
Теперь зададим последовательность <i>в виде уровней</i>:
</p>

<pre>
  esp32#>sequence 0
  esp32-seq0>tick 1
  esp32-seq0>levels 1/10 0/20 1/30 0/100
</pre>

<p>
Команда "levels" принимает параметры в формате "A/B", где A — это "1" или "0", а B — длительность уровня в тиках (от 1 до 32767). 
Для удобства можно использовать символ "/" как сокращение для 32767: "1//" то же самое, что "1/32767".
</p>

<p>
Команда выше означает: "лог.1 в течение 10 тиков, лог.0 — 20 тиков и т.д.". 
Поскольку мы установили тик равным 1 мкс, длительности получаются в микросекундах.
</p>

<p><h2 id=send><a href="#top">&#8686;</a>ОТПРАВКА ИМПУЛЬСНЫХ ПОСЛЕДОВАТЕЛЬНОСТЕЙ</h2></p>

<p>
Теперь, когда последовательность 0 сконфигурирована, можно воспроизвести её на GPIO2:
</p>

<pre>
  esp32#>sequence 0
  esp32-seq0>tick 1
  esp32-seq0>levels 1/10 0/20 1/30 0/100
  esp32-seq0>exit
  esp32#>pin 2 seq 0
</pre>

<p>
Или отправить 4 раза подряд:
</p>

<pre>
  esp32#>sequence 0
  esp32-seq0>tick 1
  esp32-seq0>levels 1/10 0/20 1/30 0/100
  esp32-seq0>exit
  esp32#>pin 2 seq 0                          &larr; один раз
  esp32#>pin 2 seq 0 seq 0 seq 0 seq 0        &larr; 4 раза подряд
</pre>

<p>
Примечание: есть и альтернативный способ отправить 4 раза — использовать команду "pin 2 seq 0 loop 4"
</p>

<p><h2 id=bits><a href="#top">&#8686;</a>ПРЕОБРАЗОВАНИЕ БИТОВ В УРОВНИ ИЛИ ИМПУЛЬСЫ</h2></p>

<p>
Хотя можно задавать уровни вручную, для длинных последовательностей это неудобно. Вместо этого можно использовать команды "<b>bits</b>", "<b>one</b>" и "<b>zero</b>", 
вместо прямого задания уровней через "<b>levels</b>".
</p>

<p>
Команда "bits" задаёт битовую строку, а команды "one" и "zero" определяют, как в уровнях выглядят лог.1 и лог.0. Например, мы хотим передать:
</p>

<p align=center>
  "HIGH 10 мкс, LOW 20 мкс, HIGH 30 мкс, LOW 100 мкс"
</p>

<p>Команды будут такими:</p>

<pre>
  esp32#>sequence 0
  esp32-seq0>one 1/10               &larr; "Один" это HIGH на 10 тиков
  esp32-seq0>zero 0/10              &larr; "Ноль" это LOW на 10 тиков
  esp32-seq0>bits 1001110000000000  
</pre>

<p>
Здесь "1" означает HIGH на 10 мкс, а "0" — LOW на 10 мкс. Чтобы достичь нужной длительности, мы просто дублируем биты:
</p>

<pre>
  1          - HIGH на 10 мкс  
  00         - LOW на 20 мкс  
  111        - HIGH на 30 мкс  
  0000000000 - LOW на 100 мкс  
</pre>

<p>
Установка "bits" сбрасывает "levels" и наоборот. После задания "tick", "bits", "one" и "zero", уровни автоматически генерируются и могут быть просмотрены через "show":
</p>

<pre>
  esp32#>sequence 0
  esp32-seq0>one 1/10               &larr; "Один" это HIGH на 10 тиков
  esp32-seq0>zero 0/10              &larr; "Ноль" это LOW на 10 тиков
  esp32-seq0>bits 1001110000000000  
  esp32-seq0>show
  %
  % Sequence #0:
  % Resolution : 1.0000uS  (Frequency: 1000000 Hz)
  % Levels are :
  % 1/10, 0/10, 0/10, 1/10, 1/10, 1/10 ....              < -- сгенерировано
</pre>

<p>
Периферия ESP32, отвечающая за генерацию импульсов, изначально предназначена для ИК-протоколов, где 1 и 0 — это не просто уровни, а импульсы. 
Они настраиваются с помощью аргументов в командах "one" и "zero". Например:
</p>
<p>
  Определим наш алфавит так: единица это HIGH на 150мкс, а затем LOW на 50 мкс; Ноль же определим наоборот: HIGH на 50 и LOW на 150 мкс.
  Передадим строчку битов 100111 используя указанный алфавит:
</p>
<pre>
  esp32#>seq 0
  esp32-seq0>tick 1
  esp32-seq0>one 1/150 0/50
  esp32-seq0>zero 1/50 0/150
  esp32-seq0>bits 100111
  esp32-seq0>show
  %
  % Sequence #0:
  % Resolution : 1.0000uS  (Frequency: 1000000 Hz)
  % Levels are :
  % 1/150, 0/50, 1/50, 0/150, 1/50, 0/150, 1/150, 0/50,
  % 1/150, 0/50, 1/150, 0/50,
  % Total: 12 levels, duration: 1200 ticks, (~1200 uS)
</pre>

<p>
Обратите внимание на то, что команды one и zero в примере выше задают не <i>уровень</i> а <i>импульс</i>, но команда show показывает, что у нас заданы уровни.
Так и должно быть: эти уровни были сгенерированы из алвавита и битовой строчки.
</p>

<p><h2 id=mod><a href="#top">&#8686;</a>МОДУЛЯЦИЯ И ОКОНЧАНИЕ ПЕРЕДАЧИ</h2></p>

<p>
В разработке...
</p>

<p><h2 id=show><a href="#top">&#8686;</a>ОТОБРАЖЕНИЕ ИНФОРМАЦИИ</h2></p>

<p>
Команда "<b>show sequence</b> <i>NUM</i>" показывает информацию о последовательности под номером NUM. Всего доступно до 10 последовательностей, нумерация начинается с 0.
</p>

<p>
Пример вывода:
</p>

<pre>
  esp32#>sh seq 0
  %
  % Sequence #0:
  % Resolution : 1.0000uS  (Frequency: 1000000 Hz)
  % Levels are
  % 1/50, 0/20,1/50, 0/20,1/50, 0/20,1/50, 0/20,1/50, 0/20, ...
  % Total: 28 levels, duration: 1180 ticks, (~1180 uS)
  % Modulation  : yes, "LOW" are modulated at 100Hz, duty 30.00%
  % Bit sequence is : (14 bits) "10011110101111"
  % Zero is 1/100 0/20
  % One is 1/50 0/20
  % Hold LOW after transmission is done
</pre>

<p><h2 id=examples><a href="#top">&#8686;</a>ПРИМЕРЫ</h2></p>

<p>
Пример: создать последовательность, при которой светодиод на GPIO2 мигает с частотой около 1 Гц.
</p>

<p>
Для частоты 1 Гц тик должен быть максимально возможным, а длительность 1 и 0 — максимальной. 
Максимальный тик — 3.2 мкс. Используем его и зададим максимальную длительность:
</p>

<pre>
  esp32-seq0>tick 3.2
  esp32-seq0>one 1//
  esp32-seq0>zero 0//
  esp32-seq0>bits 111111111000000000111111111000000000
</pre>

<p>
Знак "/" означает 32767.
</p>

<p>
Выйти из режима последовательности можно с помощью "exit" или Ctrl+Z. Можно использовать сокращения: "seq" вместо "sequence", "ex" вместо "exit".
</p>

<p>
Запускаем последовательность на пине. Если на pin2 подключен светодиод — он должен мигать:
</p>

<pre>
  esp32-seq0>ex
  esp32#>pin 2 seq 0 loop inf & &larr; "loop inf &" == "повторять бесконечно, в фоне"
  % Sending sequence 0 over GPIO 2
</pre>

<p>
Есть и дополнительные команды категории "sequence", которые не описаны здесь. Посмотреть их можно с помощью "<kbd>?</kbd>" перед именем команды и нажатием Enter.
</p>

<p>
Примечание: по умолчанию команда отправки последовательности ("<b>pin X sequence Y</b>") является блокирующей. 
Чтобы сделать её неблокирующей, добавьте "&" в конце (<a href="Basics.ru.html#background">запуск в фоновом режиме</a>).
</p>

</body>
</html>
