<!DOCTYPE html>
<html lang="en">
<head>
  <title>ESPShell : Управление вводом/выводом / Автоматизация</title>
  <link rel="stylesheet" href="espshell.css">
</head>
<body>

<p align=center><a href="index.html"><img src="i/espshell_logo.jpg" alt="ESPShell for Arduino :: Автоматизация" width="70%" height="70%" /></a></p>
<h3 align=center><a href="Automation.ru.html">[ На русском ]</a>&nbsp;&harr;&nbsp;<a href="Automation.html">[ English ]</a></h3>
<p><h2>КОМАНДЫ, ВЛИЯЮЩИЕ НА ИНТЕРФЕЙС ESPSHELL</h2></p>
<p>
Существуют случаи, когда ESPShell управляется другим программным обеспечением — то есть команды вводит и ответы читает не человек.  
Если это интерфейс Человек&harr;Машина, мы обычно ожидаем, что Машина будет отображать наш ввод. Именно поэтому мы видим, что печатаем в терминальной программе, и можем редактировать командную строку.  
А вот в интерфейсе Машина&harr;Машина нежелателен любой эхо-вывод, так как он будет мешать выводу ESPShell — машине придётся фильтровать собственный ввод.
</p>
<p>
ESPShell решает эту задачу так же, как это делают модемы.  
Модем — это пример как интерфейса Человек&harr;Машина (например, ввод AT-команд в терминале), так и Машина&harr;Машина (например, драйвер Windows общается с модемом напрямую).  
В модемах можно включить или отключить эхо-ввод с помощью <i>AT-команд</i> ("<b>ATE1</b>" и <b>"ATE0"</b>"). В ESPShell те же функции выполняются командами "<b>echo on</b>" и "<b>echo off</b>".
</p>
<p>
Весь вывод ESPShell начинается с символа "%", поэтому его легко фильтровать и обрабатывать при необходимости.
</p>
<p>
В таблице ниже перечислены команды, влияющие на интерфейс ESPShell и полезные при <i>автоматизированном</i> доступе к оболочке.  
Эти команды **не отображаются** в списке доступных команд (выводимом через "?" или "help"), поскольку они используются редко и были скрыты.
</p>

<p>
<table>
<tr>
<td>
<b><p>history</b>&nbsp;[<b>on</b>|<b>off</b>]</p>
</td><td>
<p>
  Включает или отключает историю команд.
</p><p>По умолчанию история включена и доступна через стрелки &uarr; и &darr; (в Arduino Serial Monitor это не работает).  
  ESPShell сохраняет до 20 последних команд в буфере истории. Размер буфера можно изменить, отредактировав файл <b>espshell.h</b> (см. раздел "Compile-time settings" в начале файла).
</p>
<p>
  Команда "<b>history</b>" без аргументов показывает текущий статус:
</p>
<p><pre>
  esp32#>history
  % History is enabled
  esp32#>
</pre></p>

<p>
  Значение по умолчанию — "enabled" (включено). При отключении истории также очищается память, использованная под сохранённые команды.
</p>
</td></tr>

<tr><td>
<b><p>colors</b>&nbsp;[<b>on</b>|<b>off</b>|<b>auto</b>]</p></td><td>
<p>
  Включает или отключает поддержку ANSI-цветов в терминале.
</p><p>
  Если вы используете терминальные программы вроде PuTTY или TeraTerm — лучше установить значение "on".  
  В простых терминалах, таких как Arduino Serial Monitor, нужно ставить "off", иначе экран будет заполнен непонятными символами: 1;36]m ]]J 7]m и т.п.
</p><p>
  Значение по умолчанию — "auto". В этом режиме ESPShell пытается определить тип терминала и включить/отключить цвета автоматически.  
  Определение происходит по характеру входящих данных: любые нажатия клавиш с низкими кодами (которые никогда не посылаются Arduino Serial Monitor) включают цветной режим.
</p><p>
  Если ваш терминал не поддерживает цвета, а ESPShell считает, что поддерживает — вручную отключите цвет с помощью "colors off".
</p><p>
  Выполнение команды без аргументов показывает текущий режим:
</p><p>
<pre>
    esp32#>colors
    % Color is "auto"
    esp32#>
</pre>
</p></td></tr>

<tr><td>
<b><p>echo</b>&nbsp;[<b>on</b>|<b>off</b>|<b>silent</b>]</p></td><td>
<p>
  Управляет отображением вывода оболочки и эхо-ввода пользователя.
</p>
<p>
  По умолчанию всё, что вводит пользователь, <i>отображается</i> обратно ESPShell.  
  Это поведение можно изменить командой "<b>echo</b>".  
  Вызов команды без аргументов покажет текущий режим:
</p><p>
<pre>
  esp32#>echo
  % Echo is "on"
  esp32#>
</pre>
</p><p>
  <b>echo off</b>: Отключает отображение приглашения и вводимых символов.  
  Ввод продолжает обрабатываться, но не отображается.  
  Команда влияет только на отображение ввода; вывод команд и сообщений (например, ошибок) не подавляется.
</p>
<p>
  Это эквивалент команды модема "<b>ATE0</b>".  
  Даже при отключённом эхо всё равно можно пользоваться редактированием строк и прокруткой истории — просто вы этого не увидите.
</p>
<p>
  <b>echo on</b>: Включает отображение ввода пользователя. Это поведение по умолчанию, эквивалент "<b>ATE1</b>".
</p>
<p>
  <b>echo silent</b>: Полностью отключает любой вывод ESPShell в терминал.
<ul> 
<li>Сообщения об ошибках не отображаются.</li>
<li>Ввод пользователя не отображается.</li>
<li>Команды исполняются, но <b>ничего не выводится</b>.</li>
</ul>
  Этот режим используется, когда ESPShell не должен мешать выводу скетча.  
  Скетч полностью управляет последовательным портом, а ESPShell "молчит".
</p>
</td></tr>

<tr><td>
<b><p>tty</b>&nbsp;<i>NUMBER</i></p></td>
<td><p>
  Изменяет источник ввода ESPShell на другой UART.
</p><p>
  По умолчанию вход осуществляется через UART0 (или USB-CDC), но его можно изменить командой "tty".  
  Это полезно в автоматизации, когда нужно передать управление оболочкой другому пользователю (например, подключённому к UART1).  
  Командой можно "отдать" управление, но не "забрать" обратно — чтобы вернуть контроль, пользователь на UART1 должен выполнить "tty 0".
</p>
<p><pre>
  esp32#>tty 1
  % See you there
</pre></p>
<p>
  UART, на который осуществляется переключение, должен быть инициализирован — иначе команда завершится ошибкой.
</p>
<p><pre>
  esp32#>tty 1
  % UART1 is down. Use command "up" to initialize it
  esp32#>
</pre></p>
<p>
  <i>NUMBER</i> — номер UART (от 0 до 3, в зависимости от модели ESP32) или 99 для переключения на интерфейс USB-CDC (например, доступен на ESP32-S3).
</p>

</td></tr></table>
</body>
</html>
