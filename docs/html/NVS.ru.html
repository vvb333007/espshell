<!DOCTYPE html>
<html lang="en">
<head>
  <title>Энергонезависимая память в ESP32 : NVS</title>
  <link rel="stylesheet" href="espshell.css">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="ESPShell : редактирование и просмотр содержимого NVS (Non Volatile Storage)">
  <meta name="author" content="Viacheslav Logunov">
  <meta name="repository" content="https://github.com/vvb333007/espshell">
  <meta name="project" content="ESPShell">

  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "TechArticle",
    "headline": "ESP NVS",
    "description": "Detailed reference for using ESPShell NVS editor/viewer.",
    "author": {
      "@type": "Person",
      "name": "Viacheslav Logunov"
    },
    "publisher": {
      "@type": "Organization",
      "name": "ESPShell Project",
      "url": "https://github.com/vvb333007/espshell"
    }
}
</script>

</script>
</head>
<body>
<p align=center><a href="index.html"><img src="i/espshell_logo.jpg" alt="ESPShell для Ардуино :: Энергонезависимая память" width="70%" height="70%" /></a></p>
<h3 align=center><a href="NVS.ru.html">[ На русском ]</a>&nbsp;&harr;&nbsp;<a href="NVS.html">[ English ]</a></h3>
<p>
  <ul>
    <li><a href="#intro">NVS в ESP32</a></li>
    <li><a href="#cdls">Отображение информации: cd и ls</a></li>
    <li><a href="#newrmset">Создание, удаление и редактирование значений: new, rm и set</a></li>
    <li><a href="#importexport">Экспорт и импорт: import, export</a></li>
 </ul>
</p>

<p><h2 id=intro><a href="#top">&#8686;</a>NVS в ESP32</h2></p>
<p>
Хотя ESP-IDF (а так же Arduino Core) содержат функции для работы с NVS (библиотеки EEPROM и Preferences в Arduino),
как таковой EEPROM в SoC от Espressif не предусмотрено: вместо этого EEPROM эмулируется на FLASH памяти и для этого
на флеше есть специальный раздел, который по умолчанию называется "<b>nvs</b>".
</p>
<p>
NVS в ESP устроена в виде линейной базы данных, с одним уровнем иерархии: помимо обычных "ключ=значение" в NVS
так же сохраняется т.н. <i>namespace</i>. Ключи могут иметь одинаковые имена если он относятся к разым неймспейсам.
<b>Здесь и далее по тексту: термины <i>пространство имен</i>, <i>неймспейс</i>, <i>namespace</i> и <i>каталог</i> означают одно и то же.  </b>
</p>
<p>
ESPShell позволяет перемещаться по NVS образом, похожим на работу с фаловой системой: есть знакомые <b>ls, cd, rm</b>.
Для создания новых и изменения существующих значений есть команды <b>new</b> и <b>set</b>, а для экспорта и импорта есть команды
<b>import</b> и <b>export</b>, сохраняющие NVS в виде текстового файла, что позволяет переносить NVS между разными устройствами 
и версиями NVS. Текстовый файл содержит команды ESPShell которые можно выполнить командой "exec" или "import" (на самом деле коанда "import" - это алиас команды "exec")
</p>
<p>
Для запуска NVS редактора нужно выполнить команду <b>nvs</b>:
<pre>
  esp32#>nvs
  esp32-nvs(/)>
</pre>
Появившееся приглашение говорит нам о том, что редактор запустился и мы находимся в корневом каталоге. В этом каталоге находятся <i>пространства имен</i> или namespaces,
которые можно пролистать командой "<b>ls</b>" или активировать командой "<b>cd</b>": лучше всего думать о пространствах имен как о каталогах в фаловой системе. Чтобы выйти из режима редактирования NVS нужно выполнить команду "exit" или нажать Ctrl+z
</p>

<p><h2 id=cdls><a href="#top">&#8686;</a>Отображение информации: команды <b>cd</b>, <b>ls</b> и <b>dump</b></h2></p>
<p align=center>
<img src="i/nvs_cd_ls.jpg" alt="NVS commands" width="80%" height="80%" />
<br>
<i>Рис. 1: Пример работы и вывод команд <b>cd</b> и <b>ls</b></i>
</p>


<p>
Для просмотра информации из NVS используется три команды: <b>cd</b>, <b>ls</b> и <b>dump</b>. Последняя используется лишь в тех случаях, когда команды "ls" недостаточно: например, если данные это текстовая строка, то команда <b>ls</b> покажет лишь первые 42 символа, а если тип данных - бинарный blob, то <b>ls</b>
 покажет лишь длину блока данных и первые 16 байт.

Команда <b>ls</b> имеет один необязательный параметр: пространство имен. Если параметр опущен, то используется то значение, которое было установлено командой <b>cd</b>.
Команда <b>ls</b>, будучи выполненной в корневом каталоге пространства имен выведет список пространства имен:

<pre>
 esp32-nvs(/)><b>ls</b>
 % NVS has 3 namespaces:
 %  Namespace "espshell" : 2 keys
 %  Namespace "phy" : 4 keys
 %  Namespace "nvs.net80211" : 25 keys
 esp32-nvs(/)>
</pre>
Если же зайти, скажем, в пространство имен phy (это WiFi драйвер) командой "<b>cd /phy</b>", то выполнив там команду ls без параметров, получим
табличку-список ключей и их значений:
<pre>
  esp32-nvs(/)><b>cd phy</b>
  esp32-nvs(/phy)<b>ls</b>
  % # |     Key name     |  Type  | Value (strings may be truncated. use "dump")
  % --+------------------+--------+-----------------------------------------------
  %  1| cal_address      | char[] | &lt;A binary blob, not displayed&gt;, 1 bytes
  %  2| cal_data         | char[] | &lt;A binary blob, not displayed&gt;, 1904 bytes
  %  3| cal_mac          | char[] | &lt;A binary blob, not displayed&gt;, 6 bytes
  %  4| cal_version      | uint32 | 701
  % --+------------------+--------+-----------------------------------------------
  % Total: 4 records
</pre>
 А можно - указать пространство имен непосредственно команде, ее первым аргументом:
<pre>
esp32-nvs(/phy)><b>ls ../espshell</b>
% # |     Key name     |  Type  | Value (strings may be truncated. use "dump")
% --+------------------+--------+-----------------------------------------------
%  1| tz               | char*  | UTC-07:00
%  2| hostid           | char*  | &lt;empty&gt;
% --+------------------+--------+-----------------------------------------------
% Total: 2 records
esp32-nvs(/phy)>
</pre>
<b>ПРИМЕЧАНИЕ:</b> Для команды "<b>cd</b>" существование пространства имен не обязательно: если выполнить "<b>cd sdfgsdfg</b>"
то никакой ошибки не произойдет и namespace будет установлено именно таким. При создании первого ключа в данном пространстве имен,
оно появится в списке команды "<b>ls /</b>". Если же namespace будет пустым, то после выхода из него (например, командой <b>cd /</b>)
пространство имен будет удалено.
</p>
<p>
Как уже было указано, команда <b>ls</b> выводит содержимое NVS в виде таблицы: в ней указаны названия и типы ключей, а так же их значения,
если эти значения являются числами. Строки отображаются целиком,только если они короче 42 символов, а бинарные данные (blob) не отображаются вовсе.
Для отображения строк целиком, а так же бинарных данных существует команда <b>dump <i>KEY</i></b>.
<pre>
esp32-nvs(/phy)>dump cal_address
10 11 22 33 44 55
esp32-nvs(/phy)>
</pre>
Для данных небольшого размера (т.е. до 16 байт. лимит можно изменить с помощью команды "var tbl_min_len") отображение осуществляется в виде строчки. Для данных больщего размера включается форматированный табличный вывод:
</p>
<p align=center>
<img src="i/nvs_dump_blob.jpg" alt="NVS commands" width="80%" height="80%" />
<br>
<i>Рис. 2: Пример работы и вывод команды <b>dump sta.apinfo</b></i>
</p>

<p>
Команда "<b>dump</b>" так же позволяет выводить длинные строчки, которые могут быть обрезаны командой "<b>ls</b>", целиком.
Фомат вывода, впрочем, отличается от формата вывода бинарных данных:
<pre>
  mars@esp32-nvs(/espshell)>dump hostid
  % "hostid" = "mars"

  mars@esp32-nvs(/espshell)>
</pre>
Команда <b>cd</b> позволяет <i>заходить</i> в пространства имен. Выбранное пространство имен будет отображаться в строке-приглашении:
<pre>
esp32-nvs(/)><b>cd espshell</b>
esp32-nvs(<b>/espshell</b>)>
</pre>
Как и при работе с файловой системой, команда "cd" редактора NVS может работать с относительными путями:
<pre>
esp32-nvs(<b>/espshell</b>)>cd ../phy
</pre>
Каталог / (корневой каталог NVS) не содержит ни ключей ни их значений - в корневом каталоге расположены пространства имен.
Как уже было сказано выше, NVS имеет лишь один уровень иерархии, поэтому "каталог в каталоге" создать нельзя.
<table>
  <tr><th>Команда</th><th>Описание и примеры</th></tr>
  <tr>
    <td><b>ls [<i>PATH</i>]</b></td>
    <td>
      <p>Получить листинг каталога (пространства имен) или список пространств имен
<pre>
esp32-nvs(/)>ls
%% NVS namespaces:
%  Namespace "espshell" : 2 keys
%  Namespace "phy" : 4 keys
esp32-nvs(/)>
</pre>
<pre>
esp32-nvs(/)>ls espshell
% # |     Key name     |  Type  | Value (strings may be truncated. use "dump")
% --+------------------+--------+-----------------------------------------------
%  1| hostid           | char*  | <empty>
%  2| tz               | char*  | UTC-07:00
% --+------------------+--------+-----------------------------------------------
% Total: 2 records
esp32-nvs(/)>
</pre>
Если <i>PATH</i> не указан, то использется путь, который был задан до этого командой "cd"

      </p>
    </td>
  </tr>

  <tr>
    <td><b>cd <i>PATH</i></b></td>
    <td>
      <p>Сменить текущий каталог (пространство имен) на <i>PATH</i>. В качестве <i>PATH</i> может быть указано существующее
ролстранство имен (и тогда команда "ls" что-то покажет) а может - несуществующее. В случае, когда <i>PATH</i> не существует,
он будет создан. Это поведение используется для создания новых записей: если вам захотелось создать неймспейс
"my_prefs" а в нем - записи, то нужно сменить каталог командой cd а затем создать записи командой new. Если никаких записей не создать и выйти, то такой пустой неймспейс будет тут же удален.

<pre>
  esp32-nvs(/)><b>cd my_prefs</b>
  esp32-nvs(/my_prefs)><b>ls</b>
  % Namespace "my_prefs" (partition: "nvs") is empty or does not exist

  esp32-nvs(/my_prefs)><b>new TestKey char</b>
  % Key created. Use "set TestKey ..." to set its value
  esp32-nvs(/my_prefs)>
</pre>
      </p>
    </td>
  </tr>

  <tr>
    <td><b>cd <i>PATH</i></b></td>
    <td>
      <p>Сменить текущий каталог (пространство имен) на <i>PATH</i>. В качестве <i>PATH</i> может быть указано существующее
ролстранство имен (и тогда команда "ls" что-то покажет) а может - несуществующее. В случае, когда <i>PATH</i> не существует,
он будет создан. Это поведение используется для создания новых записей: если вам захотелось создать неймспейс
"my_prefs" а в нем - записи, то нужно сменить каталог командой cd а затем создать записи командой new. Если никаких записей не создать и выйти, то такой пустой неймспейс будет тут же удален.

<pre>
  esp32-nvs(/)><b>cd my_prefs</b>
  esp32-nvs(/my_prefs)><b>ls</b>
  % Namespace "my_prefs" (partition: "nvs") is empty or does not exist

  esp32-nvs(/my_prefs)><b>new TestKey char</b>
  % Key created. Use "set TestKey ..." to set its value
  esp32-nvs(/my_prefs)>
</pre>
      </p>
    </td>
  </tr>

  <tr>
    <td><b>dump <i>KEY_NAME</i></b></td>
    <td>
      Выводит на экран значение ключа KEY_NAME в <i>текущем пространстве имен</i>. Эта команда работает только
со строками и бинарными данными.
<pre>
  esp32-nvs(/)><b>cd phy</b>
  esp32-nvs(/phy)><b>dump cal_address</b>
  % f0 9e 9e 22 7b 2c
</pre>
      </p>
    </td>
  </tr>

</table>      

</p>

<p><h2 id=newrmset><a href="#top">&#8686;</a>Создание, удаление и редактирование значений: new, rm и set</h2></p>
<p>
Чтобы создать новый элемент в NVS (т.е. создать новый ключ) следует выполнить команду "<b>new</b>", которая 
создаст новую запись и установит ее значение в 0 (для скалярных типов) или в однобайтовый буфер, внутри 
которого, опять же ноль.
<pre>
  esp32-nvs(/)><b>cd phy</b>
  esp32-nvs(/phy)><b>new Key unsigned char</b>
  % Key created. Use "set Key ..." to set its value
  esp32-nvs(/phy)>
</pre>

В данном примере мы создали запись с именем "Key", в пространстве имен "phy". Тип данных, который будет хранится в этой записи - <i>unsigned char</i>, т.е. беззнаковый байт.
Для указания типа данных используется синтаксис принятый в Си\Си++; поддерживаются следующие типы:
<ul>
  <li><b>signed</b>, <b>unsigned</b>, (или без указания знаковости вовсе)</li>
  <li><b>char</b> - 8 бит</li>
  <li><b>short</b> - 16 бит</li>
  <li><b>int</b> и <b>long</b> - 32 бита</li> 
  <li><b>long long</b> - 64 бита</li>
  <li><b>char*</b> (или <b>char *</b>)  - для строковых данных, оканчивающихся нулевым байтом</li>
  <li><b>char[]</b> (или <b>char []</b>) - для бинарных данных</li>
</ul>
А так же их комбинации вроде "unsigned short int". Все типы "указатель" будут восприняты как "char *": т.е. можно написать "unsigned int *", но воспринято это будет именно как указатель на строку (т.е. char*).
Аналогично в случае массивов, тип будет жестко преобразован к "char". Размер массива можно задавать, а можно и не задавать:
"char [10]" или "char[]" сделают одно и тоже - массив переменной длины. Длина массива, как и длина строки будет определяться
в момент установки нового значения командой "set"
</p>

<p>
Для удаления записей из NVS используется команда <b>rm</b>: она имеет один обязательный параметр. То, как работает эта команда станет понятнее из примеров.
Предположим, что мы находимся в каталоге (namespace) "espshell":
<pre>
esp32-nvs(/)><b>cd espshell</b>
esp32-nvs(<b>/espshell</b>)>
</pre>
Если мы выполним команду <b>rm tz</b>, то ключ <b>tz</b> из пространства имен <b>espshell</b> будет удален.
Чтобы удалить ВСЕ ключи в данном пространстве имен, вместо имени ключа следует указать звездочку ("*")
<pre>
esp32-nvs(/)><b>cd espshell</b>
esp32-nvs(/espshell)>
esp32-nvs(/espshell)><b>rm *</b>
% All keys in the namespace "espshell" were removed
esp32-nvs(/espshell)>
</pre>
Для удаления пространства имен целиком так же можно задать его первым аргументом команды rm:
<pre>
esp32-nvs(/phy)>rm ../espshell
</pre>
Для удаления всех записей вообще, следует выполнить команду <b>rm *</b> непосредственно в корневом каталоге (в "/") или выполнить команду "<b>rm /</b>" в любом каталоге.
Удаление записей NVS происходит без подтверждения (espshell не будет спрашивать у вас, уверены ли вы в том, что хотите удалить то или это)
</p>
<p>
Для установки значения существующего ключа (существующего или созданного командой "<b>new</b>") можно воспользоваться командой "<b>set</b>". У команды всего два параметра: название ключа и новое значение.
Например, установим ключ "tz" в пространстве имен "espshell" в значение "Hello World!":
<pre>
 esp32-nvs(/espshell)><b>set tz Hello World!</b>
 esp32-nvs(/espshell)><b>ls</b>
 % # |     Key name     |  Type  | Value (strings may be truncated. use "dump")
 % --+------------------+--------+-----------------------------------------------
 %  1| hostid           | char*  | <empty>
 %  2| tz               | char*  | <b>Hello World!</b>
 % --+------------------+--------+-----------------------------------------------
 % Total: 2 records
 esp32-nvs(/espshell)>
</pre>
Для установки бинарных данных (<b>char[]</b>) используется Си-подобный синтаксис: символы, за исключением
специальных (начинающихся с "\", например "\n" или "\22") сохраняются "как есть". Символы \r\n\t\v преобразуются в соответствии с правилами Си\Си++, символы вида \AB (где A и B - шеснадцатиричные цифры) преобразуются в байт со значением 0xAB.
Пример: установить значение cal_data равным 0x10, 0x20, Hello, 0x20, 0x10
<pre>
  esp32->nvs(/phy)set cal_data \10\20Hello\20\10
</pre>
<table>
  <tr><th>Команда</th><th>Описание и примеры</th></tr>

  <tr>
    <td><b>new <i>KEY_NAME</i> <i>KEY_TYPE</i></b></td>
    <td>
      <p>Создать ключ типа <i>KEY_TYPE</i> с именем <i>KEY_NAME</i>. В качестве <i>KEY_TYPE</i> может быть 
указан один из скалярных типов языка Си (т.е. char, short, int, long, unsigned/signed, long long, char *, char [])
Пример: создать запись cal_address, задать значение cal_address таким - 0011:2233:4455
<pre>
  esp32-nvs(/)><b>cd phy</b>
  esp32-nvs(/phy)><b>new cal_address char[]</b>
  % Key created. Use "set TestKey ..." to set its value
</pre>
Если ключ уже существует, то он будет обнулен (строки превратятся в строчки нулевой длины а массивы - в массивы состоящие из одного байта, нуля)
      </p>
    </td>
  </tr>

  <tr>
    <td><b>set <i>KEY_NAME</i> <i>KEY_VALUE</i></b></td>
    <td>
      <p>Задать новое значение для ключа <i>KEY_NAME</i>. Аргумент <i>KEY_VALUE</i> это либо число (в случае со скалярными типами) либо строка\массив. Массив и строка задаются одним и тем же способом.



Пример: Изменить запись cal_address, задать значение 0011:2233:4455
<pre>
  esp32-nvs(/phy)><b>set cal_address \00\11\22\33\44\55</b>
</pre>

      </p>
    </td>
  </tr>

  <tr>
    <td><b>rm <i>PATH</i></b></td>
    <td><p>Удалить ключи\пространства имен. В качестве аргумента указывается или название ключа или пространство имен.
Если в качестве PATH указать "/" (корневой каталог) до будут удалены вообще все данные NVS
Если в качестве PATH указать название пространства имен, то будут удалены все ключи в данном пространстве имен.
Ну а если команде передать название ключа, то команда удалит только указанный ключ.
      </p>
    </td>
  </tr>

</table>      

</p>


<p><h2 id=importexport><a href="#top">&#8686;</a>Экспорт и импорт: import, export</h2></p>
<p>
Этот раздел не дописан. Воспользуйтесь встренной системой помощи ESPShell (команда "?"), чтобы узнать подробности использования.
</p>

</body>
</html>
</body>
</html>
