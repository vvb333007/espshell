<!DOCTYPE html>
<html lang="en">
<head>
  <title>ESPShell : Introduction to ESPShell : basic concepts and command index</title>
  <link rel="stylesheet" href="espshell.css">
</head>
<body>
<p align=center><a href="index.ru.html"><img src="i/espshell_logo.jpg" alt="ESPShell for Arduino :: Index" width="70%" height="70%" /></a></p>
<p>
  <ul>
    <li><a href="#wit">Что это такое</a></li>
    <li><a href="#overhead">Сколько это все весит?</a></li>
    <li><a href="#add">Как добавить shell в ваш проект/скетч</a></li>
    <li><a href="#ui">Пользовательский интерфейс</a></li>
    <li>&nbsp;&nbsp;<a href="#keyboard">Клавиатура и горячие клавиши</a></li>
    <li>&nbsp;&nbsp;<a href="#short">Автодополнение и недополнение</a></li>
    <li><a href="#help">Встроенная система помощи</a></li>
    <li>&nbsp;&nbsp;<a href="#huse">Знак вопроса</a></li>
    <li>&nbsp;&nbsp;<a href="#hsyntax">Синтаксис страницы помощи</a></li>
    <li><a href="#background">Фоновое и основное выполнение</a></li>
    <li><a href="#cmds">Встроенные команды</a></li>
    <li>&nbsp;&nbsp;<a href="#dirs">Каталоги команд: вход и выход из основного каталога</a></li>
    <li>&nbsp;&nbsp;<a href="#index">Указатель команд / краткое описание с ссылками на документацию</a></li>
    <li><a href="#copyrights">Авторские права</a></li>
  </ul>
</p>


<p><h2 id=wit><a href="#top">&#8686;</a>ЧТО ЭТО:</h2></p>

<p>
 Это инструмент для отладки и разработки (<b>библиотека для фреймворка Arduino</b>) для использования 
 в проектах Arduino на аппаратной платформе ESP32.
</p>
<p>
 Обеспечивает интерфейс командной строки (CLI) через последовательный порт, работающий параллельно 
 с вашим скетчем Arduino. Это не отдельная программа — этот инструмент подключается к пользовательскому скетчу 
 (во время компиляции) и расширяет любой скетч (даже пустой) оболочкой.
</p><p>
 Пользователь может вводить и выполнять команды (доступно множество встроенных команд) 
 аналогично тому, как это делается в оболочке Linux, пока работает его скетч. Существуют команды для управления 
 выполнением скетча (в определённых пределах): команды приостановки и возобновления выполнения скетча.
 Достаточно просто нажать Ctrl+C, чтобы приостановить выполнение скетча, при этом оболочка продолжит работать.
</p><p>
 Пользователь взаимодействует с ESPShell либо через Serial Monitor в Arduino IDE, либо через любое другое 
 коммуникационное ПО, такое как PuTTY, TeraTerm, утилита "cu" в Linux и многие другие. Разработчик этой 
 библиотеки использует TeraTerm в Windows 10. Настройки по умолчанию как для Serial Monitor в Arduino IDE, 
 так и для TeraTerm показаны на скриншотах: <a href="TeraTerm_Default_Settings.jpg">для TeraTerm</a> 
 и для <a href="Arduino_IDE_Serial_Monitor_Default_Settings.jpg">Serial Monitor в Arduino IDE</a>. ESPShell 
 отображает ввод пользователя, поэтому "локальный эхо-режим" должен быть отключён (см. скриншоты выше).
</p>
<p>
 Эта библиотека может быть полезна разработчикам, подключающим новые устройства I<sup>2</sup>C или UART, 
 поскольку espshell имеет команды для создания/удаления аппаратных интерфейсов, отправки/приёма 
 данных. Подключение GPS-чипов (на базе UART) или GSM-модемов, создание библиотек для 
 I<sup>2</sup>C-устройств.
</p>
<p>
 Разработчикам, занимающимся автоматизацией дома: оболочка имеет команды для управления 
 GPIO (см. <a href="GPIO.ru.html">команды GPIO</a>), так что теперь для управления реле даже не нужно 
 писать код. Генератор PWM и измеритель частоты, счётчик импульсов и генератор шаблонов импульсов 
 доступны на любом GPIO.
</p>

<p align=center><img src="i/espshell.jpg" alt="ESPShell main screen" width="70%" height="70%"><br><i>Fig. 1: ESPShell, выглядит примерно так</i></p>
<p>

<p><h2 id=overhead><a href="#top">&#8686;</a>КАКОВЫ ЗАТРАТЫ ПАМЯТИ/CPU У ESPSHELL?</h2></p>
<p>
Требования по памяти и CPU у ESPShell достаточно низкие: shell спит большую часть времени, не нагружая CPU.
</p>
<p>
Последняя проверенная версия 0.99.8 имела следующие требования по памяти:
</p>

<ul>
  <li>Размер кода (<b>.text</b>) (т.е.увеличение  размера бинарника): <b>+100 кбайт</b> к скетчу</li>
  <li>Размер данных (<b>.data + .bss</b>): <b>+2822 байт</b></li>
  <li>Также есть небольшие участки кода с атрибутом <code>IRAM_ATTR</code> (т.е. они постоянно размещаются в IRAM), их суммарный размер менее 512 байт (-512 байт от доступной IRAM)</li>
</ul>
<p>
В архитектуре, которую использует Espressif, исполнение кода происходит из flash памяти (через icache), поэтому увеличением бинарника на 100кбможно пренебречь.
</p>

<p>
ESPShell выполняется на <i>другом ядре</i> (на многоядерных системах), чтобы <b>минимизировать влияние на выполнение основного скетча</b>. При старте, ESPShell определяет, на каком ядре запущен скетч, и сам пытается запуститься на другом ядре.
Т.к. чаще всего пользователи не меняют настройки компиляции в Arduino IDE, ядро, на котором выполняется Arduino Core - всегда ядро#1. Это приводит к тому, что чаще всего ESPShell будет запускаться на ядре#0
</p>




<h2><a href="#top">&#8686;</a>В ЧЁМ СМЫСЛ?</h2>
</p>
<p>
Основная идея этой библиотеки — возможность вносить изменения без необходимости перекомпиляции и повторной загрузки скетча каждый раз, 
когда вы хотите просто немного изменить поведение или провести эксперимент. Это означает гораздо меньше циклов "изменить / перекомпилировать / загрузить / запустить / посмотреть результат".
</p>
<p>
Ещё одна цель — получить контроль над выполнением скетча и возможность просматривать переменные скетча.
</p>
<p>
Скетч использует неправильный номер пина для доступа к внешнему устройству? Это можно изменить через ESPShell.<br>
Нужно изменить скорость интерфейса UART/I<sup>2</sup>C/и т. д.? Это делается командами оболочки.<br>
</p>
<p>
Сканирование шины I<sup>2</sup>C, приостановка выполнения скетча, прямое общение с GPS или GSM-модемом, подключённым по UART, 
взаимодействие с I<sup>2</sup>C-устройствами, такими как RTC или EEPROM, изменение и просмотр переменных скетча и многое другое —
всё это можно сделать с помощью команд оболочки.
</p>


<p><h2 id=add><a href="#top">&#8686;</a>КАК ДОБАВИТЬ В СВОЙ ПРОЕКТ/СКЕТЧ ARDUINO:</h2></p>
<p>
 Эта библиотека не требует вызова каких-либо функций для запуска оболочки, кроме одной строки 
 кода: добавьте <br>
<pre>
#include "espshell.h"
</pre>
где-нибудь в начале вашего скетча — и всё.
</p><p>
 Скомпилируйте и загрузите скетч как обычно. ESPShell запускается автоматически при старте скетча, 
 перехватывая управление и запуская свою задачу. Оболочка перехватывает управление в самом начале, до
 вызова <span class=func>setup()</span> и <span class=func>loop()</span> Arduino, а также до <span class=func>app_main()</span> в ESP-IDF.
</p><p>
Когда ESPShell запускается, она отображает приветственный баннер и готова принимать команды:
</p>
<p align=center>
<img src="i/welcome_banner.jpg" alt="ESPShell Welcome Banner" width="70%" height="70%" />
<br>
<i>Рис. 2: Приветственный баннер</i>
</p>
<p>
 <b>Примечание:</b> ESPShell ожидает инициализации Serial; если пользовательский скетч не инициализирует Serial
 (то есть <span class=func>Serial.begin( ... )</span> ни разу не вызывается), то ESPShell будет неактивна, находясь в состоянии сна, 
 ожидая запуска Serial (то есть, когда скетч вызовет <span class=func>Serial.begin( ... )</span>). Если ESPShell была <a href="Customizing.ru.html">настроена для использования другого UART</a> (например, UART1), 
 то она будет ждать вызова <span class=func>Serial1.begin( ... )</span>.
</p>

<p><h2 id=ui><a href="#top">&#8686;</a>Пользовательский интерфейс</h2></p>

<p>
ESPShell хорошо работает в Serial Monitor Arduino IDE, однако предпочтительнее подключаться к оболочке 
через терминальные программы. Автор использует TeraTerm в Windows, но любое другое ПО тоже подойдёт. 
Serial Monitor Arduino — это не полноценная терминальная программа, и это ограничивает использование 
некоторых функций ESPShell: подсветки синтаксиса, горячих клавиш, UART-моста и других.
</p>

<p>
ESPShell предоставляет интерфейс командной строки (CLI) с возможностью редактирования команд, историей 
введённых команд и подсветкой синтаксиса;
</p><p>
Пользователь взаимодействует с оболочкой через последовательный интерфейс (UART или USB-CDC), 
вводя команды и/или нажимая горячие клавиши; ESPShell отображает приглашение (например, "<b>esp32#&gt;</b>"), 
принимает и выполняет команды, введённые пользователем — аналогично оболочке Linux: 
анализирует ввод, выполняет запрошенные действия, отображает ошибки (если они есть), и цикл повторяется.
</p>

<p align=center>
<img src="i/espshell1.jpg" width="70%" height="70%" alt="Typical view" /><br>
<i>Рис. 2: Типичная сессия espshell: пользователь выполняет команду &quot;<b>show cpuid</b>&quot;</i>
</p>

<p><h3 id=keyboard><a href="#top">&#8686;</a>Keyboard use & key bindings</h3></p>

<p>
  These keys are recognized by ESPShell:
</p>
<p>
<table border="1" cellspacing="0" cellpadding="6">
  <thead>
    <tr>
      <th>Клавиша</th>
      <th>Значение / Выполняемое действие</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[ENTER]</td>
      <td>Выполнить команду, прервать выполняемую команду</td>
    </tr>
    <tr>
      <td>[ARROWS]</td>
      <td>Стрелки: перемещение курсора влево/вправо. Вверх/вниз — прокрутка истории команд.</td>
    </tr>
    <tr>
      <td>[DEL]</td>
      <td>Как в Блокноте</td>
    </tr>
    <tr>
      <td>[BACKSPACE]</td>
      <td>Как в Блокноте</td>
    </tr>
    <tr>
      <td>[HOME] и [END]</td>
      <td>Эти клавиши не работают. Вместо них используйте Ctrl+A как &lt;HOME&gt; и Ctrl+E как &lt;END&gt;.</td>
    </tr>
    <tr>
      <td>[TAB]</td>
      <td>Быстрый переход от одного слова к другому. Быстрое переключение между аргументами команды — многократное нажатие позволяет прокручивать их все.</td>
    </tr>
    <tr>
      <td>Ctrl+R</td>
      <td>Поиск в истории. Нажмите Ctrl+R и начните ввод. Нажмите &lt;ENTER&gt;, чтобы найти команду, введённую ранее.</td>
    </tr>
    <tr>
      <td>Ctrl+K</td>
      <td>Очистить строку от курсора до конца</td>
    </tr>
    <tr>
      <td>Ctrl+L</td>
      <td>Очистить экран, сохранить пользовательский ввод, включить цвета и показать подсказку</td>
    </tr>
    <tr>
      <td>Ctrl+Z</td>
      <td>То же, что и "exit" + &lt;ENTER&gt;. Переход на уровень вверх в иерархии команд. Используется для выхода из подкаталогов.</td>
    </tr>
    <tr>
      <td>Ctrl+C</td>
      <td>Приостановка выполнения скетча. Возобновление — командой "resume".</td>
    </tr>
    <tr>
      <td>[ESC]56[ESC]</td>
      <td>Ввод произвольного ASCII-символа: нажмите &lt;ESC&gt;, затем введите ASCII-код (1–3 цифры) и снова &lt;ESC&gt;. <br>Пример: отправить break (Ctrl+C, код 3): &lt;ESC&gt;3&lt;ESC&gt;</td>
    </tr>
    <tr>
      <td>[ESC] [BACKSPACE]</td>
      <td>Если просто &lt;BACKSPACE&gt; удаляет 1 символ, то &lt;ESC&gt; + &lt;BACKSPACE&gt; удаляет 1 слово.</td>
    </tr>
  </tbody>
</table>
</p><p>
<p>Обратите внимание, что страницу справки по комбинациям клавиш можно открыть, выполнив команду оболочки <b>"? keys"</b>:</p>

<p align=center>
<img src="i/keys.jpg" width="70%" height="70%" /><br>
<i>Рис. 3: Встроенная справка по команде <b>? keys</b></i>
</p>

<p>
Выполнив команду <b>"? keys"</b>, можно найти комбинации клавиш, которые работают даже в «примитивных» терминалах: 
если, например, стрелки в вашем терминале работают некорректно, можно использовать Ctrl+F и Ctrl+B в качестве альтернативы:
Ctrl+F двигает курсор вперёд ([F]orward &rarr;), Ctrl+B — назад (&larr;).
</p>

<p>
Назначения клавиш должны быть более или менее интуитивными для пользователей Linux shell.
</p>

<p>
<i>ПРИМЕЧАНИЕ: Простые терминальные программы, такие как Serial Monitor Arduino, не умеют отправлять коды клавиш Ctrl+C и Ctrl+Z, 
а они необходимы, например, для работы с GSM/LTE-модемами.</i>
</p>


<p><h2 id=short><a href="#top">&#8686;</a>Автодополнение против неполных команд</h2></p>
<p>
ESPShell не будет автоматически дополнять команды при нажатии [TAB]: вместо этого ESPShell просто принимает <i>неполный</i> ввод, то есть команды и их аргументы можно <i>сокращать</i>. Давайте рассмотрим разницу:
</p><p>
В Linux-оболочке (например, <i>bash</i>) пользователь вводит "<b>upt</b>" и нажимает &lt;TAB&gt;, чтобы оболочка дополнила команду до "<b>uptime</b>". 
</p><p>
В отличие от этого, в ESPShell можно просто ввести "<b>upt</b>" (или даже "<b>up</b>") и нажать &lt;Enter&gt;. ESPShell не требует полного ввода команды, достаточно ввести, например, "seq" вместо "sequence".
</p><p>
Такие команды, как, например, &quot;<b><a href="GPIO.ru.html">pin 19 out high delay 500 low delay 100</a></b>&quot;, 
можно записывать как &quot;<b>p 19 o h d 500 l d 500</b>&quot; — и оболочка всё поймёт.
</p>
<p>
ESPShell старается отличать сокращённые команды, чтобы избежать случайного выполнения неправильных команд: команды "<b>uptime</b>" и "<b>uart 1</b>" обе можно сократить до "<b>u</b>". 
Но так как команда "<b>uptime</b>" не имеет аргументов, а "<b>uart</b>" всегда требует аргумент, оболочка сможет распознать, что "<b>u 1</b>" — это "<b>uart 1</b>", а не "<b>uptime</b>".
Однако так бывает не всегда, поэтому не стоит чрезмерно сокращать: "sh c" может означать как "show counters", так и "show cpuid", и в таком случае ESPShell выберет первую команду из списка — в данном случае это будет "show counters". 
(Список команд можно получить, введя команду "?" или "help")
</p>

<p><h2 id=help><a href="#top">&#8686;</a>Встроенная система справки</h2></p>

<p>
ESPShell старается быть информативным и имеет встроенную систему справки, которая может выполнять несколько функций — предоставлять страницы справки для команд и предоставлять детали и возможные решения при возникновении ошибок: например, попытка использовать несуществующий пин, скорее всего, приведет к сообщению о номерах пинов, доступных на данной плате.
</p>

<p>
<h3 id=huse><a href="#top">&#8686;</a>Вопросительный знак</h3></p><p>
Система справки доступна через команду/горячую клавишу "<b>?</b>": как команда, она отображает страницы справки для команд и список доступных команд. Как горячая клавиша, она отображает справку для команды, которую пользователь в данный момент вводит.
<p>
Для получения списка всех доступных команд нужно ввести "?" и нажать &lt;Enter&gt;:
</p>

<p align=center>
<img src="i/qm_list.jpg" width="70%" height="70%" alt="Пример страницы списка команд"/><br>
<i>Рис. 4: Доступные команды</i>
</p>
<p>
  Обратите внимание, что <b>iic, uart, sequence, files, camera</b> — это <a href="#dirs"><i>каталоги команд</i></a>, каждый из которых имеет свой собственный набор команд.<br>
  Пользователь может читать страницы справки для команд, введя вопросительный знак "?" и ключевые слова: либо <a href="#short">сокращённые</a>, либо полные.

Например, чтобы прочитать страницу справки для команды "<b>sequence</b>", можно ввести "<b>? seq</b>" и нажать &lt;ENTER&gt;; другие примеры: "? pin", "? count" и так далее: вопросительный знак и имя команды отобразят страницы справки для команд.
</p><p>
Ниже приведён пример выполнения "<b>? count</b>":
</p>

<p align=center>
<img src="i/qm_count.jpg" width="70%" height="70%" alt="Пример страницы справки"/><br>
<i>Рис. 5: Встроенная страница справки для команды <b>count</b></i>
</p>

<p>
  Однако если вы хотите прочитать страницы справки <b>во время ввода команды</b> (например, если вы не помните, какой аргумент должен быть следующим), просто нажмите "?" — и страница справки появится выше вашего ввода. Вы можете попробовать ввести "cou" и нажать "?", чтобы увидеть страницу справки для команды "count".
</p>

<p>
  Вопросительный знак — это горячая клавиша, и такое поведение может быть раздражающим в случаях, когда вам нужно ввести символ "?" и не вызывать систему справки. Например, если вы пишете строку "Hello World?" в какой-то файл, нажатие "?" вызовет страницу справки, и это не то, что мы хотим. Одно из решений — использовать &lt;ESC&gt;63&lt;ESC&gt; для ввода ASCII-кода (63 — это "?") или отключить обработку горячей клавиши "?" с помощью команды:
<pre>
  esp32#>var bypass_qm 1
</pre>
(<i>Команда <b>var</b> здесь устанавливает внутреннюю переменную оболочки "bypass_qm" в значение 1</i>)
</p>

<p>
<h3 id=hsyntax><a href="#top">&#8686;</a>Синтаксис страницы справки</h3>
</p><p>
  Когда отображается типичная страница справки, можно заметить, что для описания <i>синтаксиса команды</i> используются специальные символы (вместе с цветами, на цветных терминалах). Синтаксис команды можно найти в самом начале любой страницы справки. Давайте рассмотрим страницу справки для команды "count": (см. <a href="qm_count.jpg"><i>Рис. 5</i></a>, или введите "? count" и нажмите &lt;ENTER&gt;)
</p>
<p>
    <pre>
    esp32#>? count
    % -- Pulse counter --
    % "count PIN [NUMBER | trigger | filter LENGTH]*"
    %
    % Count pulses on pin PIN for NUMBER milliseconds (default value is 1 second)
    % Optional "trigger" keyword suspends the counter until the first pulse
    % Optional "filter LEN" keyword ignores pulses shorter than LEN nanoseconds
    ...
    ...
</pre>
</p>
<p>
  Это первые строки страницы справки для команды "? count". Здесь мы можем увидеть те самые <i>специальные символы</i>: квадратные скобки "[" и "]", вертикальную черту "|", звёздочку "*" и несколько слов, написанных прописными буквами.
</p><p>
<table>
<tr><td><p><b>Символ</b></p></td><td><p><b>Значение</b></p></td></tr>
<tr><td><p align=center>UPPERCASE</p></td><td><p>Число или строка текста. Любой ввод пользователя. В примере выше говорится, что команда "count" имеет 3 таких параметра: номер пина, время измерения и длина. В большинстве команд параметр в верхнем регистре — это число, однако некоторые команды могут ожидать и текст.</p></td></tr>
<tr><td><p align=center>lowercase</p></td><td><p>Это ключевые слова: сама команда, слова "trigger" и "filter". На страницах справки они обычно желтые (имя команды — белое).</p></td></tr>
<tr><td><p align=center>[&nbsp;&nbsp;&nbsp;]</p></td><td><p>Квадратные скобки используются для обозначения НЕОБЯЗАТЕЛЬНЫХ параметров. На цветных терминалах они отображаются темно-желтым цветом. В примере выше есть только 1 обязательный параметр (номер пина), в то время как остальные — необязательные и могут быть опущены.</p></td></tr>
<tr><td><p align=center>|</p></td><td><p>Вертикальная черта: это логическая операция "ИЛИ". В значении "это ИЛИ то". Пример выше говорит, что мы можем ввести ЧИСЛО <b>или</b> ключевое слово "trigger" <b>или</b> ключевое слово "filter" с параметром LENGTH.</p></td></tr>
<tr><td><p align=center>*</p></td><td><p>Звездочка, расположенная рядом с закрывающей скобкой (т.е. "<b>)*</b>" или "<b>]*</b>"), указывает на то, что всё внутри скобок может появляться несколько раз.</p></td></tr>              
</table>
<p>
Другие символы, которые также используются на страницах справки (но не в примере выше) — это <i>символ диапазона</i> (две точки, "<b>..</b>") и <i>обязательный символ</i> (круглые скобки, "<b>()</b>"):
</p>
<p>
<table>
  <tr><td>1<b>..</b>10</td><td>Число в диапазоне от 1 до 10 включительно.</td></tr>
  <tr><td><b>(</b>arg1|arg2|...|argN<b>)*</b></td><td>Обязательный аргумент: любая комбинация arg1 и arg2, но не пустая (должен быть указан хотя бы один аргумент).</td></tr>
  <tr><td><b>[</b>arg1|arg2|...|argN<b>]*</b></td><td>Необязательный аргумент: любая комбинация arg1 и arg2, включая пустой аргумент.</td></tr>
</table>
</p>


<p>
<h2 id=background><a href="#top">&#8686;</a>Выполнение в фоновом и основном режиме</h2>
</p><p>
По умолчанию все команды ESPShell являются блокирующими (ну, большинство из них, не все). Это
означает, что <b>оболочка будет ожидать завершения команды</b> перед тем, как начать принимать новый 
ввод: команды выполняются поочередно, одна за другой.
</p><p>
Это поведение можно изменить, используя символ &amp;:
</p><p>
Добавление "&quot;&amp;&quot;" как <b>последнего аргумента</b> к любой команде инструктирует ESPShell выполнять эту конкретную 
команду как отдельную задачу, параллельно с другими процессами. Это поведение
хорошо известно пользователям Linux, где <b>&amp;</b> используется для выполнения команд в фоновом режиме.
</p><p>
Эта опция (выполнение в фоновом режиме) особенно полезна для команд "pin" и 
"count", которые могут занять много времени для завершения. Каждая выполняемая фоновая команда 
выделяет около 5000 байт памяти стека, которая освобождается после завершения выполнения.
</p><p>
Любую фоновую команду можно остановить с помощью команды <a href="Kill_Suspend_And_Resume.ru.html">kill</a>
</p>

<p>
<h2 id=cmds><a href="#top">&#8686;</a>Встроенные команды ESPShell</h2>
</p><p>

  <h3 id=dirs><a href="#top">&#8686;</a>Командные директории</h3>
</p><p>
  Команды ESPShell сгруппированы в <i>командные директории</i>: команды, связанные с UART, находятся в директории "uart", команды, работающие с файлами, в директории "files" и так далее.
  Главная командная директория — это та, которую вы видите, когда запускаете ESPShell. Главная командная директория содержит команды И другие командные директории; вы можете подумать о командных директориях как о настоящих каталогах файловой системы, заполненных исполняемыми файлами.
</p><p>
  Если пользователь хочет выполнить команды, связанные с UART, он/она должен <b>войти</b> в соответствующую
  командную директорию:
</p><p>
<pre>
    Пример: вход в режим настройки UART

      esp32#>uart 0 
      esp32-uart0>
</pre>
</p><p>
 Выполнение команды "<b>uart 0</b>" переключает текущую командную директорию в директорию команд UART0; затем, нажав "<b>Ctrl+Z</b>" или выполнив команду "<b>exit</b>", можно вернуться в Главную директорию.
</p><p>
 Когда вы находитесь в любой командной директории, команды из внешней директории доступны и могут быть выполнены, даже если они не отображаются в списке команд:
</p><p><pre>
  Пример:

      Вход в командную директорию UART0:

      esp32#>uart 0
      % You are about to configure the Serial espshell is running on. Be careful
      % Entering UART configuration mode. Ctrl+Z or "exit" to return
      % Hint: Main commands are still avaiable (but not visible in "?" command list)

      Список всех доступных команд:

      esp32-uart0>?
      % Enter "? command" to get details about specific command.
      % Enter "? keys" to display the espshell keyboard help page
      %
      % "?"          : Commands list & help
      % "up"         : Initialize uart (pins/speed)
      % "baud"       : Set baudrate
      % "down"       : Shutdown
      % "read"       : Read data from UART
      % "tap"        : Talk to device connected
      % "write"      : Send bytes over this UART
      % "exit"       : Exit

      Выполнение команды, которая не отображается в списке, но существует в главной директории команд:

      esp32-uart0>uptime
      % Last boot was 17 seconds ago
      % Restart reason was "Board power-on"
      esp32-uart0>
</pre>
В приведенном примере оболочка ищет в главной командной директории, когда обнаруживает, что команда "uptime" отсутствует в директории uart0.
</p><p>
Чтобы выйти из командной директории, используется команда "<b>exit</b>".
Примечание: Ctrl+Z является горячей клавишей для команды "exit".
</p><p>
Другие командные директории, доступные в ESPShell: <a href="UART.ru.html">uart</a>, <a href="I2C.ru.html">i<sup>2</sup>c</a>, <a href="Filesystems.ru.html">files</a>, <a href="Pulse_Generator.ru.html">sequence</a> и <a href="Camera.ru.html">настройки камеры</a>.
</p><p>









<h3 id="index"><a href="#top">&#8686;</a>Индекс команд / Краткое описание с ссылками на страницы документации</h3>
</p><p>
<table><tr><td><b>Команда</b></td><td><b>Описание</b></td></tr>
<tr><td><p><a href="GPIO.ru.html">pin</a></p></td><td><p><b>pin</b> <i>PIN</i> [<i>ARG1</i> | <i>ARG2</i> | ... | <i>ARGn</i> ]*</p><p>Разные команды для работы с пинами (GPIO).<br>

            Установка или чтение значений пинов, выполнение analogRead(), установка режимов пинов, сохранение/восстановление состояния пинов, включение PWM и многое другое. Это можно использовать для генерации низкочастотных периодических сигналов.
</p><p>
            Последовательность команд с аргументами (может быть всего один аргумент), при этом первым аргументом всегда является номер пина. Команда позволяет создавать маленькие "программы" 
            (последовательность действий и задержек), которые выполняются на пинах (GPIO).
</p><p>
            Дополнительную информацию и примеры по этой команде можно найти в <a href="GPIO.ru.html">документации</a> (связанная команда: "show iomux")
</p></td></tr>

<tr><td><p><a href="PWM.ru.html">pwm</a></p></td><td><p><b>pwm</b> <i>PIN</i> <i>FREQ</i> [<i>DUTY</i> [<i>CHANNEL</i>]]<br><b>pwm</b> <i>PIN</i> off</p> <p>Генераторы PWM.<br>
            Включение/выключение PWM сигнала на произвольном пине. Частота, коэффициент заполнения и канал выбираются. Полное описание можно найти в <a href="PWM.ru.html">документации по PWM</a>
            (связанная команда: "show pwm")
</p></td></tr>

<tr><td><p><a href="Pulse_Counter.ru.html">count</a></p></td><td><p><b>count</b> <i>PIN</i> [<i>NUMBER</i> | infinite | trigger | filter <i>LENGTH</i>]*</p> <p>Счетчик импульсов / измеритель частоты.<br>
            Позволяет считать импульсы / измерять частоту на произвольном пине. На ESP32 имеется 8 аппаратных счетчиков (ESP32-S3 имеет только 4), которые могут работать одновременно. Поддерживает отсроченный счет.
</p><p>
            Для подробностей см. <a href="Pulse_Counter.ru.html">Pulse Counter / Измеритель частоты</a> (связанная команда: "show counters")
</p></td></tr>

<tr><td><p><a href="Sketch_Variables.ru.html">var</a></p></td><td><p><b>var</b> [<i>NUMBER</i> | <i>NAME</i> | <i>NAME VALUE</i> ]</p><p>Манипуляции с переменными Sketch. См. <a href="Sketch_Variables.ru.html">эту страницу</a> для использования
           этой функции в вашем коде; команда используется для отображения/изменения переменных sketch в реальном времени. Поддерживаются простые типы и массивы простых типов;
</p><p>
           Другая возможность этой команды — преобразование чисел в/из двоичной/восьмеричной/десятичной/шестнадцатеричной систем.
</p></td></tr>

<tr><td><p><a href="I2C.ru.html">iic</a></p></td><td><p><b>iic</b> <i>NUM</i></p><p>Вход в режим шины I<sup>2</sup>C.<br> Настройка и использование (чтение/запись/сканирование) указанной 
           шины I<sup>2</sup>C.
           Подробное описание команд I<sup>2</sup>C <a href="I2C.ru.html">можно найти здесь</a>
</p><p>

<tr><td><p><a href="UART.ru.html">uart</a></p></td><td><p><b>uart</b> <i>NUM</i></p> <p>Доступ к интерфейсу UART X.<br> Настройка и использование (чтение/запись/мост) интерфейса UART.
           См. <a href="UART.ru.html">этот документ</a> для подробной информации о настройке и использовании интерфейсов UART
</p></td></tr>

<tr><td><p><a href="Pulse_Generator.ru.html">sequence</a></p></td><td><p><b>sequence</b> <i>NUM</i></p> <p>Режим генератора сигналов.<br> Позволяет генерировать произвольные паттерны сигналов с 
             точными временными интервалами на любом пине. См. документацию в 
             <a href="Pulse_Generator.ru.html">Pulse generator</a> для получения дополнительной информации. Простые паттерны также
             могут быть сгенерированы с помощью команды "pin" (см. <a href="GPIO.ru.html">манипуляции с GPIO</a>)
             (связанная команда: "show sequence")
</p></td></tr>

<tr><td><p><a href="Filesystems.ru.html">files</a></p></td><td><p><b>files</b></p> <p>Вход в режим файлового менеджера.<br> Этот режим позволяет пользователю выполнять основные команды файловой 
           системы (перечень содержимого каталога, создание файлов и каталогов,
           редактирование файлов и передача файлов). Подробнее см. в <a href="Filesystems.ru.html">этом файле</a>
</p></td></tr>

<tr><td>show</td><td><p><b>show</b> KEYWORD [<i>ARG1</i> | <i>ARG2</i> | ... | <i>ARGn</i>]*</p><p>
В ESPShell пользователь может отображать различную информацию (о sketch, процессоре, памяти и т. д.)
используя команду "show".</p>
<p>
В зависимости от используемого ключевого слова может быть 0, 1, 2 или больше аргументов:
</p>
<p>
<ul>
<li><b><a href="GPIO.ru.html#iomux">show iomux</a></b></li>
<li><b><a href="GPIO.ru.html#displaying">show pin</a></b></li>
<li><b><a href="CPU.ru.html#cpuid">show cpuid</a></b></li>
<li><b><a href="PWM.ru.html#show">show pwm</a></b></li>
<li><b><a href="Pulse_Counter.ru.html#show">show counters</a></b></li>
<li><b><a href="Pulse_Generator.ru.html#show">show sequence</a></b></li>
<li><b><a href="Filesystems.ru.html#show">show mount</a></b></li>
<li><b><a href="Memory.ru.html#show">show memory</a></b></li>
<li><b><a href="Camera.ru.html#show">show camera</a></b></li>
</ul>
</p>
</td></tr>

<tr><td><p><a href="Kill_Suspend_And_Resume.ru.html">suspend</a><br>
<a href="Kill_Suspend_And_Resume.ru.html">resume</a><br>
<a href="Kill_Suspend_And_Resume.ru.html">kill</a></p></td><td><p><b>kill</b> [-9 | -15] <i>TASK_ID</i><br><b>suspend</b> [<i>TASK_ID</i>]<br><b>resume</b> [<i>TASK_ID</i>]</p> <p>Команды управления процессами: завершить, приостановить или возобновить задачу.<br> Эти 3 
           команды описаны подробно <a href="Kill_Suspend_And_Resume.ru.html">здесь</a> и используются
           согласно их назначениям: для приостановки/возобновления или завершения процесса 
          (задача FreeRTOS или фоновая команда ESPShell)
</p></td></tr>

<tr><td><p><a href="Automation.ru.html">echo</a><br>
<a href="Automation.ru.html">history</a><br>
<a href="Automation.ru.html">colors</a><br>
<a href="Automation.ru.html">tty</a></p></td><td><p><b>echo</b> [on | off | silent ]</p><p><b>colors</b> [on | off | auto ]</p><p><b>history</b> [on | off ]</p><p><b>tty</b> <i>NUM</i></p>  <p>Эти 4 команды управляют вводом и выводом в shell;
             См. <a href="Automation.ru.html">эту страницу</a> для деталей синтаксиса команд и подробного 
             описания.
</p></td></tr>

<tr><td><p>uptime</p></td><td><p><b>uptime</b></p> <p>Показывает, сколько времени прошло с последней перезагрузки; показывает причину последней 
             перезагрузки. Для этой команды нет отдельной документации: это простая команда без аргументов.
</p></td></tr>

<tr><td><p><a href="CPU.ru.html">cpu</a></p></td><td><p><b>cpu</b> <i>FREQ</i></p> <p>Устанавливает частоту процессора в FREQ МГц. Список поддерживаемых частот будет 
             показан при попытке установить неподдерживаемую частоту (например, 99 МГц):
</p><p><pre>         
             Пример:   
                 esp32#>cpu 99
                 % Поддерживаемые частоты: 240, 160, 120, 80, 40, 20 и 10
</pre>
</p></td></tr>

<tr><td><p>reload</p></td><td><p><b>reload</b></p> <p>Перезагружает ESP32. Это программная перезагрузка, которая не сбрасывает регистры аппаратных
             (периферийных) устройств.
</p></td></tr>

<tr><td><p>nap</p></td><td><p><b>nap</b> [<i>NUM</i>]</p> <p>Переводит процессор в режим <b>легкого сна</b>.<br>
             Без аргументов: переводит процессор в сон до любого события на UART:  
             Процессор просыпается от активности UART (нажмите любую клавишу для пробуждения). Условие пробуждения — 3 
             положительных фронта. Рекомендуется использовать &lt;Enter&gt; как клавишу отмены.
<pre>         
             Пример:   
                 esp32#>nap
                 % Entering light sleep
</pre>
</p><p>                                  

             С аргументом: переводит процессор в легкий сон на <i>NUM</i> секунд, процессор просыпается только по таймеру, других способов отмены сна нет.
</p></td></tr>
</table></p>














<p><h2 id=copyrights><a href="#top">&#8686;</a>COPYRIGHTS</h2></p>
<p><pre>
ESPShell library
Copyright (c) 2024, 2025 Viacheslav Logunov &lt;vvb333007@gmail.com&gt;, all rights reserved
</pre></p>

<p>
ESPShell contains code from Editline library (ancient version, <a href="https://searchfox.org/mozilla-central/source/js/src/editline/editline.c">from here</a>):
</p>
<p>
<pre>
Copyright 1992,1993 Simmule Turner and Rich Salz, All rights reserved

This software is not subject to any license of the American Telephone and 
Telegraph Company or of the Regents of the University of California.

Permission is granted to anyone to use this software for any purpose on any 
computer system, and to alter it and redistribute it freely, subject to the
following restrictions:

1. The authors are not responsible for the consequences of use of this software,
   no matter how awful, even if they arise from flaws in it.

2. The origin of this software must not be misrepresented, either by explicit 
   claim or by omission. Since few users ever read sources, credits must appear
   in the documentation.
3. Altered versions must be plainly marked as such, and must not be 
   misrepresented as being the original software. Since few users ever read 
   sources, credits must appear in the documentation. 

4. This notice may not be removed or altered.
</pre>
</p>

<p>
ESPShell contains code from Arduino Core 3.0.5
</p>
<p>
<pre>
Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
</pre>
</p>

</body>
</html>
