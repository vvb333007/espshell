<!DOCTYPE html>
<html lang="ru">
<head>
  <link rel="stylesheet" href="espshell.css">
  <title>ESPShell : Всё о пинах : Управление GPIO</title>
</head>
<body>
<p align=center><a href="index.ru.html"><img src="i/espshell_logo.jpg" alt="ESPShell для Arduino :: Главная"  width="70%" height="70%" /></a></p>
<p>
  <ul>
    <li><a href="#pins">Пины ESP32 (GPIO)</a></li>
    <li><a href="#pin">Команда "pin": Универсальный инструмент для работы с GPIO</a></li>
    <li><a href="#displaying">Отображение информации о пине</a></li>
    <li><a href="#settings">Настройка режима пина</a></li>
    <li><a href="#reading">Чтение/запись значений пина</a></li>
    <li><a href="#pulse">Последовательности импульсов, ШИМ и тайминги</a></li>
    <li><a href="#saving">Сохранение/восстановление состояния пина</a></li>
    <li><a href="#loop">Автоповтор команды (цикл)</a></li>
    <li><a href="#iomux">IO_MUX и GPIO Matrix</a></li>
    <li><a href="#speed">Замечания о скорости выполнения</a></li>
    <li><a href="#examples">Различные примеры</a></li>
  </ul>
</p>

<p id="pins"><h2><a href="#top">&#8686;</a>ПИНЫ ESP32 (GPIO)</h2></p>

<p>
ESP32 имеет множество пинов ("пинов", "выходов" или "GPIO" — все эти термина используются в этой документации взаимозаменяемо), 
которые можно настроить как универсальные входы/выходы (GPIO) или назначить им специальные функции. 
Например, пин может выступать в роли линии TX для аппаратного UART-интерфейса или служить линией CLOCK
 для шины I<sup>2</sup>C.
</p>
<p>
Некоторые пины имеют системные роли и называются "бутстрап-пинами". Эти пины сообщают загрузчику, как 
инициализировать аппаратное обеспечение при запуске. Их можно использовать, если это не мешает процессу загрузки: если подключенное к такому пину внешнее устройство при включении питания и загрузке ESP32 не выдает сигналы в этот пин, то проблем не будет. Проблемы возникнут, если ваше устройство, подключеное к bootstrap пинам
при старте системы выдаст туда что-то неожиданное: это действие сконфигурирует ESP32 в непредсказуемый режим (например, напряжение питания шины SPI0 может поменяться и сжечь вашу микросхему flash).
</p><p>
Некоторые пины зарезервированы для внутреннего использования. Например, пины 6–11 на большинстве плат с оригинальным 
ESP32 используются для доступа к внутренней flash-памяти. Взаимодействовать с этими пинами можно только если вы действительно понимаете, что вы делаете: ваш код должен быть размешен целиком в кэше, и это только одно из многих требований</p><p>
Некоторые пины работают только на вход и не могут быть переконфигурированы в режим выхода.. Такие, например, встречаются в орининальном ESP32 (в ESP32S3, например, таких пинов нет).
</p>
<p>
Как узнать, какие пины можно использовать безопасно, а какие нет? Просто исполните команду "<b>pin</b>", без аргументов и увидите справочную информацию по пинам на вашей плате; Но обо всем по порядку.
</p>

<p id="pin"><h2><a href="#top">&#8686;</a>КОМАНДА "PIN": УНИВЕРСАЛЬНЫЙ ИНСТРУМЕНТ ДЛЯ РАБОТЫ С GPIO</h2></p><p>

В ESPShell вы можете управлять пинами с помощью команды "<b>pin</b>", которая используется как для отображения информации о конкретном пине, 
так и для его настройки.</p><p></p><p> Можно установить пин в состояние HIGH или LOW, отправлять различные последовательности импульсов, включать или 
отключать ШИМ, настраивать направление и режим пина, подтяжки, считывать и устанавливать цифровое и аналоговое значение и т.п.
</p>
<p>
В отличие от <i>digitalRead(...)</i>, который не работает на пинах, используемых аппаратными интерфейсами (например, нельзя использовать 
<code>digitalRead()</code> на линиях I<sup>2</sup>C), ESPShell может читать цифровые значения на <b>любом</b> GPIO. Шелл использует низкоуровневый доступ к состояниям пинов, поэтому 
совершенно спокойно можно считывать значение пина, даже если на нём активен ШИМ или, скажем, UART0. Для этого используется команда "<b>pin NUM read</b>".
</p>
<p>
Команда "<b>pin</b>" принимает несколько аргументов, которые обрабатываются слева направо. Первый аргумент — номер пина, остальные — ключевые слова и/или дополнительные номера пинов для применения операций. Эти аргументы можно рассматривать как простую программу, выполняемую на указанных пинах.
</p><p>
Например, "<b>pin 2 save out high load</b>" — валидная команда с четырьмя аргументами/ключевыми словами. Она сохраняет состояние GPIO2 во внутреннем регистре, переводит пин 2 в режим OUTPUT, устанавливает его в HIGH и сразу восстанавливает исходное состояние.
</p><p>
Примеры команд "<b>pin</b>":
</p><p><pre>
    pin 1 high 2 low
    pin 2 pwm 1000 0.5 delay 250 pwm 1000 0.25 delay 250 loop infinite
</pre>
</p>

<p>
Команда "<b>pin</b>" может работать с одним или несколькими пинами одновременно. Пример ниже показывает команду, которая устанавливает пины 2 и 4 в HIGH, а пины 18 и 19 — в LOW:
<pre>
esp32#>pin 2 high 4 high 18 low 19 low
</pre>
Здесь 2, 4, 18 и 19 — номера пинов, а "low" и "high" — <i>ключевые слова</i>. Ключевые слова могут встречаться несколько раз и в различных комбинациях в одной команде "<b>pin</b>", как показано в <a href="GPIO.html#examples">разделе с примерами</a> ниже.
</p>

<p>
Теперь, собственно, команды:
</p>

<p id="displaying"><H2><a href="#top">&#8686;</a>ОТОБРАЖЕНИЕ ИНФОРМАЦИИ О ПИНЕ</h2></p>

<p>
Чтобы отобразить информацию о произвольном пине: введите "<b>pin</b>", затем номер пина и нажмите &lt;Enter&gt;.
</p><p>
Пример ниже показывает базовую информацию о GPIO 0, 8, 1 и 4 (ESP32 DevKit):
</p><p><pre>
esp32#>pin 0
% GPIO0 is unused, strapping pin
% Mode: INPUT, PULL_UP,
% Output is disabled
% Input is done via IO MUX, (function: GPIO0)
% Maximum drive current is 20 mA
% Digital pin value is HIGH (1)
%
esp32#>pin 8
% GPIO8 is reserved
% Mode: INPUT, OUTPUT, PULL_UP,
% Output is done via GPIO Matrix, provides path for signal ID: 2
% Input is done via GPIO Matrix, connected signal IDs: 2,
% Maximum drive current is 20 mA
% Digital pin value is LOW (0)
%
esp32#>pin 1
% GPIO1 is in use, configured as UART_TX
% Mode: INPUT,  input is floating
% Output is disabled
% Input is done via IO MUX, (function: U0TXD)
% Maximum drive current is 20 mA
% Digital pin value is HIGH (1)
%
esp32#>pin 4
% GPIO4 is unused
% Mode: INPUT, PULL_DOWN,
% Output is disabled
% Input is done via IO MUX, (function: GPIO4)
% Maximum drive current is 20 mA
% Digital pin value is LOW (0)
%
esp32#></pre>
</p>
<p id="show_pin">
Альтернативный способ - использовать команду "<b>show pin</b> <i>NUM</i>". Она эквивалентна команде "<b>pin</b> <i>NUM</i>" — обе отображают информацию о пине с номером <i>NUM</i>. 
Единственное отличие состоит в том, что команда "<b>show pin</b>" принимает несколько аргументов (номеров пинов), поэтому пример выше можно записать одной командой: "<b>show pin 0 8 1 4</b>".
</p>

<p>
Сколько пинов доступно на вашей плате ESP32? Чтобы узнать, какие пины существуют, а какие нет, можно использовать команду "<b>pin</b>" без аргументов:
</p>
<p align=center>
<img src="i/pin_exist.jpg" alt="pin" width="80%" height="80%" />
<br>
<i>Рис. 1: Вывод команды "pin" (на ESP32-WROOM32D Dev Module)</i>
</p>
<p>
На скриншоте виден результат работы команды: список пинов, которые трогать НЕ НАДО ("<b>Used by SoC</b>") и список пинов, которые,в принципе, использовать можно, но необъодимо удостовериться, что эти пины не используются еще кем-то. Так, на скриншоте пины 1 и 3 помечены как доступные ("<b>Available</b>"), но на самом деле на этих пинах сконфигурирован UART0, использовать их нельзя.
</p>

<p id="settings"><h2><a href="#top">&#8686;</a>НАСТРОЙКА РЕЖИМА ПИНА</h2>
</p>
<p>Команда <b>pin</b> используется для установки <i>режима</i> пина (например, PULL_UP/PULL_DOWN, INPUT/OUTPUT, OPEN_DRAIN) и его <i>значения</i>; эквивалент <i>pinMode()</i> и/или <i>digitalRead()/digitalWrite()/analogRead()</i>.</p>
<p>
<table><tr><td><b>Ключевое слово</b></td><td><b>Описание и примеры</b></td></tr>
<tr>
<td><p><i>NUMBER</i></p></td><td><p><b>pin </b><i>PIN_NUMBER</i><br />Номер пина для работы. Первый аргумент команды "pin" — это номер пина. Этот <i>номер пина</i> может встречаться несколько раз в одной команде "pin". Пример ниже устанавливает пины 0, 1 и 2 в LOW:<br>
<pre>
            esp32#>pin 0 low 1 low 2 low
</pre></p><p>
Команда, содержащая только числа в качестве аргументов (например, "pin 1 2 3"), является валидной, но ничего не делает.
</p></td></tr>

<tr><td><p>out</p></td><td><p><b>pin </b><i>PIN_NUMBER</i> <b>out</b><br />Установить пин в режим OUTPUT: эквивалент <i>pinMode(pin, OUTPUT)</i>.</p></td></tr>
<tr><td><p>in</p></td><td><p><b>pin </b><i>PIN_NUMBER</i> <b>in</b><br />Установить пин в режим INPUT: аналогично <i>pinMode(pin, INPUT)</i>.</p></td></tr>
<tr><td><p>up</p></td><td><p><b>pin </b><i>PIN_NUMBER</i> <b>up</b><br />Включить внутренний подтягивающий резистор (~45 кОм), флаг PULL_UP.</p></td></tr>
<tr><td><p>down</p></td><td><p><b>pin </b><i>PIN_NUMBER</i> <b>down</b><br />Включить внутренний подтягивающий резистор(~45 кОм), флаг PULL_DOWN.</p></td></tr>
<tr><td><p>open</p></td><td><p><b>pin </b><i>PIN_NUMBER</i> <b>open</b><br />Настроить пин на работу в режиме "open drain", OPEN_DRAIN.</p></td></tr>
</table>
<p>
<b>Пример:</b> сконфигурировать пин 2 как INPUT_PULLUP и OPEN_DRAIN 
<pre>
  esp32#>pin 2 in open up
</pre>
<b>Пример:</b> сконфигурировать пин 2 как INPUT, PULL_DOWN и OUTPUT, а пин 4 - как INPUT 
<pre>
  esp32#>pin 2 in out down 4 in
</pre>
</p>
<p>
Обратите внимание, что режим пина не добавляется к текущей конфигурации — он перезаписывается. 
Например, если мы установим пин 2 в OUTPUT с PULL_UP командой "<code>pin 2 out up</code>", 
а затем попытаемся добавить флаг INPUT с помощью "<code>pin 2 in</code>", пин 2 останется только с флагом INPUT.
</p>
<p>
Правильный способ применить несколько флагов — указать их все сразу, например: "<code>pin 2 in out up</code>".
Если команда <b>pin</b> включает любое из упомянутых выше ключевых слов режима, текущий режим пина сначала сбрасывается, а затем применяется новый.
</p>


<p id="reading"><h2><a href="#top">&#8686;</a>ЧТЕНИЕ/ЗАПИСЬ ЗНАЧЕНИЙ ПИНА</h2></p>

<table>
  <tr>
    <td><b>Ключевое слово</b></td>
    <td><b>Описание и примеры</b></td>
  </tr>

  <tr>
    <td>read</td>
    <td>
      <p><b>pin </b><i>PIN_NUMBER</i> <b>read</b></p>
      <p>Выполняет цифровое чтение.</p>
      <p>Команда "<code>pin 2 read</code>" выполняет <code>digitalRead()</code> на пине 2 и показывает результат (HIGH или LOW).</p>
      <p>
        Пины, настроенные только на OUTPUT, будут временно переключены в INPUT/OUTPUT автоматически. 
        В отличие от стандартного <code>digitalRead()</code>, эта команда может читать значение <b>любого</b> GPIO, независимо от его текущей конфигурации или использования — 
        например, она может читать значения с пинов, используемых для UART или I<sup>2</sup>C.
      </p>
      <p>
        <pre>
Пример: чтение значений GPIO#1.

  esp32#>pin 1 read
  % GPIO1 : logic 1

  esp32#>pin 1 read
  % GPIO1 : logic 0
  esp32#>
        </pre>
        В примере выше пин 1 сначала возвращает "1", а затем "0". 
        Это происходит потому, что на ESP32 GPIO1 обычно используется как UART_TX, а при выполнении команды происходит вывод данных через этот же пин.
      </p>
    </td>
  </tr>

  <tr>
    <td><p>aread</p></td>
    <td>
      <p><b>pin </b><i>PIN_NUMBER</i> <b>aread</b></p>
      <p>Выполняет аналоговое чтение.</p>
      <p>
        Эта команда настраивает однократное измерение АЦП на указанном пине и возвращает <b>абсолютное</b> значение АЦП. В зависимости от настройки АЦП, считываемые значения могут быть в диапазоне от 0 до 4095.
      </p>
    </td>
  </tr>

  <tr>
    <td><p>low</p></td>
    <td><p><b>pin </b><i>PIN_NUMBER</i> <b>low</b></p><p>Устанавливает логический "0" на пине.</p></td>
  </tr>

  <tr>
    <td><p>high</p></td>
    <td>
  <p><b>pin </b><i>PIN_NUMBER</i> <b>high</b></p>
      <p>Устанавливает логическую "1" на пине (т.е. <code>digitalWrite(pin, HIGH)</code>).</p>
      <p>
        Оба ключевых слова <code>high</code> и <code>low</code> автоматически устанавливают режим OUTPUT для пина, если он ещё не установлен.
        Поэтому следующие команды функционально эквивалентны:
      </p>
      <p>
        <pre>
"pin 2 high"
"pin 2 out high"
        </pre>
      </p>
    </td>
  </tr>
</table>


<p>
<b>Пример:</b> сконфигурировать пин 2 как OUTPUT и установить на нем высокий уровень (HIGH)
<pre>
  esp32#>pin 2 out high
</pre>
<b>Пример:</b> прочитать цифровое, а затем и аналоговое значение с пина 36:
<pre>
  esp32#>pin 36 read aread
</pre>
</p>


<p id="pulse"><h2><a href="#top">&#8686;</a>СИГНАЛЬНЫЕ ПОСЛЕДОВАТЕЛЬНОСТИ, PWM И ТАЙМИНГИ</h2></p>

<p>
Команда "<b>pin</b>" может использоваться для генерации ШИМ-сигналов, точных высокочастотных последовательностей импульсов (с модуляцией или без, для ИК-приёмников),
а также для генерации сверхнизкочастотных сигналов
</p>

<table>
  <tr>
    <td><b>Ключевое слово</b></td>
    <td><b>Описание и примеры</b></td>
  </tr>

  <tr>
    <td><b>sequence</b>&nbsp;<i>NUM</i></td>
    <td>
      <p><b>pin </b><i>PIN_NUMBER</i> <b>sequence</b> <i>SEQUENCE_ID</i></p>
      <p>Передаёт <b>предварительно заданную</b> последовательность. Создаются они с помощью команды <a href="Pulse_Generator.html">sequence</a> и идентифицируются по <i>ID номеру</i>.</p>
      <pre>
Пример: Послать последовательность#5 на пин номер 2:
  
  esp32#>pin 2 seq 5
      </pre>
    </td>
  </tr>

  <tr>
    <td><b>pwm</b>&nbsp;<i>FREQ</i>&nbsp;<i>DUTY</i></td>
    <td>
      <p><b>pin </b><i>PIN_NUMBER</i> <b>pwm</b> <i>FREQUENCY</i> <i>DUTY</i></p>
      <p>
        Включает ШИМ-выход на указанном выводе. <code>FREQ</code> — это частота в герцах, а <code>DUTY</code> — скважность.
        Оба параметра обязательны. Установка частоты в 0 отключает генерацию ШИМ.
        <code>DUTY</code> — это число с плавающей точкой в диапазоне (0..1).
      </p>
      <pre>
Пример: Включить ШИМ 5кГц , скважностью 50% на пине номер 2:
  
  esp32#>pin 2 pwm 5000 0.5
      </pre>
      <p>
        Примечание: хотя команда <a href="PWM.html"><b>pwm</b></a> делает то же самое, что и "<code>pin &lt;PIN&gt; pwm &lt;FREQ&gt; &lt;DUTY&gt;</code>", 
        отдельная команда <b>pwm</b> предоставляет больше параметров для настройки.
      </p>
    </td>
  </tr>

  <tr>
    <td><b>delay</b>&nbsp;<i>NUM</i></td>
    <td>
      <p><b>pin </b><i>PIN_NUMBER</i> <b>delay</b> <i>MILLISECONDS</i></p>
      <p>
        Вставляет задержку в <i>NUM</i> миллисекунд перед выполнением следующего ключевого слова в последовательности команды "<b>pin</b>". 
        Это может использоваться для создания простых временных шаблонов:
      </p>
      <pre>
Пример: Помигать светодиодиком, подключенным к пину номер 2, с частотой 0.5 Гц
  
  esp32#>pin 2 high delay 1000 low delay 1000 loop infinite &
      </pre>
      <p>
        Пример выше устанавливает на выводе 2 уровень HIGH на 1 секунду, затем LOW на 1 секунду, и повторяет цикл. 
        Символ <a href="Basics.html#background">"&"</a> запускает команду в фоновом режиме.
      </p>
    </td>
  </tr>
</table>


<p id="saving"><h2><a href="#top">&#8686;</a>СОХРАНЕНИЕ / ВОССТАНОВЛЕНИЕ СОСТОЯНИЯ ВЫВОДА, УДЕРЖАНИЕ СОСТОЯНИЯ</h2></p>

<p>
Можно временно сохранить состояние пина (т.е. режим, подтяжку, значение, функцию IOMUX), а затем восстановить его. 
</p>
<p>
Ключевые слова "<b>save</b>" и "<b>load</b>" используются для сохранения и восстановления состояния вывода. 
Для хранения используется <i>внутренний регистр</i>, куда каждый раз сохраняется состояние пина: то есть новая операция <b>save</b> перезапишет предыдущую.
</p>
<p>
Также есть возможность зафиксировать (заморозить) выходное значение пина, чтобы предотвратить любые изменения. Все попытки записи кем угодно в пин будут игнорироваться, а значение на пине будет такое, какое было в момент заморозки. 
Однако, как только заморозка будет снята, все изменения, сделанные во время фиксации, будут применены немедленно. Для заморозки\разморозки используются ключевые слова "<b>hold</b>" и "<b>release</b>":
</p>

<table>
  <tr><td><b>Ключевое слово</b></td><td><b>Описание и примеры</b></td></tr>

  <tr>
    <td><b>hold<br>release</b></td>
    <td>
      <p><b>pin </b><i>PIN_NUMBER</i> <b>hold | release</b></p>
      <p>
        Замораживает выходное значение вывода. Замороженный вывод сохраняет своё значение даже после программной перезагрузки, если питание продолжает подаваться на чип.
        Однако полная перезагрузка с отключением питания (POWERUP) снимает заморозку.
      </p>
      <pre>
Пример: Заморозить значение на пине 2:

  esp32#>pin 2 hold
      </pre>

      <p>
        "<b>pin X release</b>" снимает заморозку с вывода, ранее зафиксированного с помощью "<b>pin X hold</b>", и применяет все изменения, сделанные в период заморозки.
      </p>
      <pre>
Пример: Разморозить пин 2:

  esp32#>pin 2 release
      </pre>
    </td>
  </tr>

  <tr>
    <td><b>save<br>load</b></td>
    <td>
      <p><b>pin </b><i>PIN_NUMBER</i> <b>save | load</b></p>
      <p>Сохраняет состояние вывода во внутренний регистр и восстанавливает его позже с помощью "<b>load</b>".</p>
      <pre>
Пример: Сохранить состояние пина 2, произвести чтение аналогового сигнала, восстановить состояние пина

  esp32#>pin 2 save aread load
      </pre>
      <p>
        "<b>pin X load</b>" восстанавливает ранее сохранённое состояние вывода. Пример выше демонстрирует использование ключевого слова "<b>load</b>".
      </p>
    </td>
  </tr>
</table>


<p id=loop><h2><a href="#top">&#8686;</a>АВТОПОВТОР КОМАНДЫ "<b>pin</b>"</h2></p>

<p>
Команду <b>"pin"</b> можно зациклить для повторения: для этого используется ключевое слово <b>loop</b>, которое должно быть размещено в <b>конце команды</b>.  
Зацикленные команды можно прерывать, нажав клавишу &lt;Enter&gt; или с помощью команды <b>"kill"</b> (для остановки команд запущенных в фоновом режиме).
</p>

<table>
<tr><td><b>Ключевое слово</b></td><td><b>Описание и примеры</b></td></tr>
<tr>
<td><b>loop</b></td>
<td>
<p><b>pin</b> <i>НОМЕР_ПИНА</i> ... <b>loop</b> <i>COUNT</i>| <b>infinite</b></p>
<p>
  Повторяет всю команду <code>COUNT</code> раз. Ключевое слово <b>"loop COUNT"</b> должно быть в конце команды.  
  <code>COUNT</code> - это число повторов команды или ключевое слово "<b>infinite</b>", что задает количество повторений равным 2^32-1, что фактически является бесконечным числом в большинстве случаев.
</p>
<p>
Примеры:
<pre>
    esp32#>pin 2 delay 1000 loop inf &   &larr; Фоновая команда, повторяется бесконечно
    esp32#>pin 2 delay 1000 loop 10 &    &larr; Фоновая команда, повторяется 10 раз
</pre></p>
</td>
</tr>
</table>

<p>
<b>Пример</b>: переключать пин 2 из состояния HIGH в LOW и обратно с максимальной скоростью:
<pre>
  esp32#>pin 2 high low loop inf
  % Repeating whole command 4294967294 times, press &lt;Enter&gt; to abort
  % Key pressed, aborting..
  esp32#></pre>
</p>


<p id="iomux"><h2><a href="#top">&#8686;</a>IO_MUX и GPIO MATRIX</h2></p>

<p>
IO_MUX и GPIO_Matrix (с подчеркиванием или без) — это аппаратные блоки внутри микросхемы ESP32.  
Они используются для подключения выводов GPIO к периферийным аппаратным модулям внутри ESP32.  
Каждый пин может быть настроен на одну из пяти (или шести на некоторых моделях ESP32) <i>функций</i>.  
Пин может использоваться как обычный GPIO или выполнять специализированную функцию (например, UART TX).  
Команда "<b>show iomux</b>" отображает текущие соответствия между пинами и функциями:
</p>

<p align="center">
  <img src="i/show_iomux.jpg" width="70%" height="70%" alt="вывод команды show iomux" /><br>
  <i>Рис. 2: Вывод команды <b>show iomux</b></i>
</p>

<p>
<ul>
  <li>Текущая активная функция отображается инвертированным цветом (или помечается "*" на монохромных дисплеях).</li>
  <li>Пины, которые активно используются (т.е. имеют установленный драйвер), отмечены красным и знаком восклицания ("<b>!</b>").</li>
  <li>Пины, помеченные зелёным, являются только входными (не могут использоваться как выход).</li>
</ul>
</p>

<p>
На примере вывода выше видно, что GPIO0 назначен на функцию 0 (обычный GPIO0).  
Изменение его на функцию 2 не повлияет на поведение, так как обе функции соответствуют "простому GPIO" —  
Функция 0 маршрутизируется через IO_MUX, а функция 2 — через GPIO_Matrix.
</p>

<p>
Пины с 6 по 11, отмеченные красным на рисунке 2, используются для доступа к встроенной флеш-памяти.
</p>

<p>
IO_MUX обеспечивает немного более высокую производительность по сравнению с GPIO_Matrix.  
Однако GPIO_Matrix предоставляет большую гибкость, позволяя почти любую периферию подключать к почти любому пину.  
Использование GPIO_Matrix для сигналов флеш-памяти (вместо IO_MUX) добавляет небольшую задержку около 25 нс.
</p>

<p>
Если снова взглянуть на рисунок 2, вы заметите, что пины 1 и 3 установлены на функцию №0, которая соответствует UART0 TX и UART0 RX соответственно.  
Означает ли это, что только пины 1 и 3 можно использовать для настройки UART0?
</p>

<p>
Нет, не означает.
</p>

<p>
UART0 также может быть настроен через GPIO Matrix — именно это происходит, когда вы назначаете UART0 на пины, отличные от 1 и 3.  
Например, если мы хотим инициализировать UART0 на пинах 18 и 19, эти пины будут переведены в режим <i>GPIO Matrix</i>, что отображается выбором функции №2 (на ESP32; на других моделях ESP используется функция №1).  
После выбора режима GPIO Matrix, пины подключаются к <i>периферийным сигналам</i> UART0_RX и UART0_TX.  
Маршрутизация сигналов (т.е. подключение или отключение) может также выполняться вручную — см. ключевое слово "<b>matrix</b>" ниже.
</p>

<p>
Снова, рисунок 2 показывает, что если мы хотим инициализировать UART1 на его предпочтительных пинах (т.е. через IO_MUX, минуя GPIO Matrix), нужно использовать GPIO9 и GPIO10.  
Когда эти пины настроены на функцию №4, они становятся UART1_RX и UART1_TX.  
К сожалению, GPIO9 и GPIO10 уже используются для подключения к микросхеме флеш-памяти.
</p>

<p>
Что насчёт UART2?  
Если его инициализировать на пинах 16 и 17 с выбранной функцией №4, они становятся пинами высокоскоростного интерфейса UART.  
Таким образом, пины 16 и 17 являются <i>предпочтительными</i> для UART2.  
Создадим интерфейс UART2 и снова взглянем на таблицу IOMUX:
</p>

<pre>
esp32#>uart 2
esp32-uart2>up 16 17 115200
esp32-uart2>show iomux
</pre>

<p align="center">
<img src="i/uart2_1617.jpg" width="70%" height="70%" alt="вывод команды show iomux" /><br>
<i>Рис. 3: Вывод команды <b>show iomux</b> после инициализации UART2 на предпочтительных пинах</i>
</p>

<p>
Что произойдёт, если мы инициализируем UART2 на пинах 18 и 19?  
Давайте посмотрим:
</p>

<pre>
esp32#>uart 2
esp32-uart2>up 18 19 115200
esp32-uart2>show iomux
</pre>

<p align="center">
<img src="i/uart2_1819.jpg" width="70%" height="70%" alt="вывод команды show iomux" /><br>
<i>Рис. 4: Вывод команды <b>show iomux</b> после инициализации UART2 на альтернативных пинах</i>
</p>

<p>
На этот раз пины установлены на функцию №2, которая соответствует режиму GPIO Matrix, что приводит к немного более медленной работе UART.  
Если вы выполните команду <code>show pin 18 19</code>, то увидите, что пины 18 и 19 подключены к <i>периферийным сигналам</i> UART2_RX и UART2_TX:
</p>

<pre>
esp32-uart2>sh pin 18 19
% GPIO18 is available, configured as UART_RX
% Mode: INPUT, input is floating
% Output is disabled
% Input is done via GPIO Matrix, connected signal IDs: 198,
% Maximum drive current is 20 mA
% Digital pin value is LOW (0)
%
% GPIO19 is available, configured as UART_TX
% Mode: INPUT, OUTPUT, input is floating
% Output is done via GPIO Matrix, provides path for signal ID: 198
% Input is done via GPIO Matrix
% Maximum drive current is 20 mA
% Digital pin value is HIGH (1)
</pre>


<p id="speed"><h2><a href="#top">&#8686;</a>ЗАМЕЧАНИЯ О СКОРОСТИ ИСПОЛНЕНИЯ</h2></p>
<p>
Команда "<b>pin</b>" является <i>интерпретатором</i>; она не <i>компилирует</i> свои ключевые слова для более быстрой обработки. Вместо этого ключевые слова <i>интерпретируются</i> каждый раз при их выполнении, даже внутри циклов. Так насколько быстро это работает?
</p>
<p>
Вы можете провести простой эксперимент: соедините пины 2 и 4 перемычкой и выполните команду "<b>pin 2 low high loop infinite &</b>" и "<b>count 4</b>".  
Первая команда переключает пин 2 между высоким и низким состоянием в фоновом цикле, а вторая команда подсчитывает импульсы, поступающие на пин 4.  
На классическом ESP32, работающем на 240 МГц, этот эксперимент показывает частоту импульсов около 80 кГц.  
Однако добавление всего лишь 1-миллисекундной задержки значительно снижает скорость исполнения:  
команда "<b>pin 2 low high delay 1 loop infinite &</b>" дает сигнал частотой около 500 Гц.
</p>
<p>
Другим фактором, который может повлиять на производительность команды "<b>pin</b>", является длина ключевых слов.  
ESPShell выполняет команды немного быстрее, если аргументы <i>сокращены</i>.  
Например, "<b>pin 2 l h loo inf &</b>" выполнится немного быстрее, чем "<b>pin 2 low high loop infinite &</b>".
</p>
<p>
Еще один важный момент: команды, такие как "<b>pin 2 low high loop inf &</b>", можно остановить только с помощью команды "<b><a href="Kill_Suspend_And_Resume.html">kill -9</a></b>".  
Это потому, что такие команды не содержат <b>задержек</b>, а задержки — это единственные точки, где команда "<b>kill</b>" (без "<b>-9</b>") может аккуратно прервать задачу.  
Для аккуратного завершения вы можете либо добавить задержку в 1 мс (что, как показано выше, значительно снижает производительность), либо использовать "<b>kill -9</b>", чтобы принудительно завершить задачу.
</p>

<p id="examples"><h2><a href="#top">&#8686;</a>ПРИМЕРЫ</h2></p>

<p>
Рассмотрим несколько простых примеров, демонстрирующих, как использовать команду "<b>pin</b>". 
Часто легче учиться на примерах, чем читать бесконечные таблицы и описания.
</p>

<p><b>Пример </b>1. Отобразить информацию о GPIO4:</p>
<p><pre>
   esp32#>pin 4
</pre></p>

<p><b>Пример </b>2. Установить пин 33 в режим OUTPUT и INPUT, включить PULL_UP и установить пин в состояние HIGH:</p>
<p><pre>
   esp32#>pin 33 out in up high
</pre></p>

<p><b>Пример </b>3. Сохранить состояние пина, установить его в режим OUTPUT и HIGH, затем восстановить исходное состояние:</p>
<p><pre>
   esp32#>pin 33 save out high
   esp32#>pin 33 load
</pre></p>

<p>
   ПРИМЕЧАНИЕ: Установка пина в "low" или "high" автоматически устанавливает его в режим OUTPUT. 
   Внутри шелла, ключевое слово "high" преобразуется в "out high". 
   Поэтому вышеуказанную команду можно упростить до:
</p>
<p><pre> 
   esp32#>pin 33 save high
   esp32#>pin 33 load
</pre></p>

<p><b>Пример </b>4. Прочитать аналоговое значение с пина 33:</p>
<p><pre>
   esp32#>pin 33 aread
</pre></p>

<p>
   ПРИМЕЧАНИЕ: Команда "aread" использует функцию <code>analogRead()</code>, 
   которая перенастроит пин как часть процесса чтения. 
   После выполнения "<b>pin 33 aread</b>" пин будет перенастроен и может больше не отвечать на <code>digitalRead()</code>. 
   Чтобы сохранить исходную конфигурацию, используйте "save" и "load":
</p>
<p><pre>
   esp32#>pin 33 read save aread load
</pre></p>

<p>
   Аргументы обрабатываются слева направо. 
   В данном случае сначала считается цифровое значение, затем состояние пина сохраняется, после чего выполняется аналоговое чтение и восстановление состояния.
</p>

<p>
<b>Пример </b>5. Сохранить состояние пина, установить его в режим OUTPUT и HIGH на 250 мс, LOW на 100 мс, снова HIGH на 50 мс, затем восстановить исходную конфигурацию:
</p>
<p><pre>
  esp32#>pin 33 save high delay 250 low delay 100 high delay 50 load
</pre></p>

<p>
  ПРИМЕЧАНИЕ: Хотя простые сигнальные последовательности можно создать с использованием "delay", эта команда обычно используется для базовых задач, таких как управление реле. 
  Для более сложных сигналов рекомендуется использовать <a href="Pulse_Generator.ru.html">генератор импульсов</a> или <a href="PWM.ru.html">ШИМ</a>. Одно из немногих мест, где оправдана генерация сигнала с помощью <b>delay</b> - это генерация сигналов с частотами ниже 1-2 герц: ШИМ на таких частотах недоступен.
</p>

<p>
  ПРИМЕЧАНИЕ: Команду "pin" можно прервать во время длительных задержек (>3 секунд), нажав любую клавишу в терминале 
  или отправив любой символ через Serial Monitor в Arduino IDE. 
  Короткие задержки (менее трех секунд) не могут быть прерваны — вам нужно дождаться их завершения.
</p>

<p><b>Пример </b>7. Установить пин 2 в HIGH, пин 3 в LOW, подождать 1 секунду, затем инвертировать состояния пинов:</p>
<p><pre>
  esp32#>pin 2 high 3 low delay 1000 2 low 3 high
</pre></p>

<p><b>Пример </b>8. Моргание светодиода на GPIO2 с задержкой 500 мс, 20 раз:</p>
<p><pre>
  esp32#>pin 2 high delay 500 low delay 500 loop 20
</pre></p>

<p>
  ПРИМЕЧАНИЕ: Когда используется ключевое слово "loop", команда "pin" становится <i>прерываемой</i>: 
  нажатие любой клавиши в терминале или Serial Monitor в Arduino IDE прервет выполнение команды.
</p>

<p><b>Пример </b>9. Моргание светодиода на GPIO2 при яркости 30%:</p>
<p>
  Для регулировки яркости используем ШИМ с частотой 5 кГц и скважностью 30%:
</p>
<p><pre>
  esp32#>pin 2 pwm 5000 0.3 delay 500 pwm 0 0 delay 500 loop infinite
</pre></p>

<p>
Как показано в приведенных примерах, некоторые команды "pin" могут потребовать длительного времени для выполнения. 
Команды с "loop", команды большими значениями "delay" могут выполняться десятки секунд или даже минуты. 
Вы можете прервать их в любой момент, нажав &lt;Enter&gt; в вашем терминале или Serial Monitor.
</p>

<p><b>Пример </b>10. Отправить S.O.S. в Морзе, повторяя бесконечно:<br>
(Морзе для SOS — ...---..., команда разделена на две строки для удобства чтения.)
</p>
<p><pre>

  pin 2 h d 100 l d 100 h d 100 l d 100 h d 100 l d 300 h d 200 l d 100 h d 200 
        l d 100 h d 200 l d 300 h d 100 l d 100 h d 100 l d 100 h d 100 l d 500 loop inf

</pre></p>


<p><b>Пример </b>12. Подключить периферийный сигнал 77 к постоянному "1", а сигнал 78 к постоянному "0":</p>
<p><pre>
  esp32#>pin 0x38 matrix in 77
  esp32#>pin 0x30 matrix in 78
</pre></p>

<p>
Этот пример использует специальные виртуальные пины: 0x30 (постоянная 0) и 0x38 (постоянная 1). 
Эти пины могут использоваться как источники фиксированных логических уровней для команд "pin 0x30 matrix" и "pin 0x30 matrix".
</p>

<p align="center"><img src="i/virtual_pins.jpg" alt="show pin 0x30 0x38" width="75%" height="75%"></p>

<p><b>Пример </b>13. Мониторинг аналогового сигнала на пине 36:</p>
<p>
Используем ключевые слова "aread", "delay" и "loop" для создания простого аналогового монитора:
</p>
<p><pre>
  esp32#>pin 36 aread delay 500 loop infinite
</pre></p>

<p>Эта команда работает в переднем плане и обновляет аналоговое значение каждые 500 мс. 
Можно, добавив <a href="Basics.ru.html#background">символ <b>&</b></a>, запустить эту же команду в фоновом режиме, работать она будет так же (но можно будет пользоваться шеллом, пока она исполняется), приостанавливать команду (см "<a href="Kill_Suspend_And_Resume.ru.html">suspend <i>TASK_ID</i></a>"), </p>

<p align="center"><img src="i/pin_aread.jpg" alt="pin 36 aread" width="75%" height="75%"></p>

</body>
</html>


