<!DOCTYPE html>
<html lang="ru">
<head>
  <link rel="stylesheet" href="espshell.css">
  <title>ESPShell : Всё о пинах : Управление GPIO</title>
</head>
<body>
<p align=center><a href="index.html"><img src="i/espshell_logo.jpg" alt="ESPShell для Arduino :: Главная"  width="70%" height="70%" /></a></p>
<p>
  <ul>
    <li><a href="#pins">Пины ESP32 (GPIO)</a></li>
    <li><a href="#pin">Команда "pin": Универсальный инструмент для работы с GPIO</a></li>
    <li><a href="#displaying">Отображение информации о пине</a></li>
    <li><a href="#settings">Настройка режима пина</a></li>
    <li><a href="#reading">Чтение/запись значений пина</a></li>
    <li><a href="#pulse">Последовательности импульсов, ШИМ и тайминги</a></li>
    <li><a href="#saving">Сохранение/восстановление состояния пина</a></li>
    <li><a href="#loop">Автоповтор команды (цикл)</a></li>
    <li><a href="#iomux">IO_MUX и GPIO Matrix</a></li>
    <li><a href="#speed">Замечания о скорости выполнения</a></li>
    <li><a href="#examples">Различные примеры</a></li>
  </ul>
</p>

<p id="pins"><h2><a href="#top">&#8686;</a>ПИНЫ ESP32 (GPIO)</h2></p>

<p>
ESP32 имеет множество пинов (или GPIO — оба термина используются в этой документации взаимозаменяемо), которые можно настроить как универсальные входы/выходы (GPIO) или назначить им специальные функции. Например, пин может выступать в роли линии TX для аппаратного UART-интерфейса или служить линией CLOCK для шины I<sup>2</sup>C.
</p>
<p>
Некоторые пины имеют системные роли и называются "бутстрап-пинами". Эти пины сообщают загрузчику, как инициализировать аппаратное обеспечение при запуске. Их можно использовать, если это не мешает процессу загрузки.
</p><p>
Некоторые пины зарезервированы для внутреннего использования. Например, пины 6–11 на большинстве плат ESP32 Dev используются для доступа к внутренней flash-памяти. Взаимодействовать с этими пинами можно только если ваша программа уже закэширована процессором, чтобы не возникало промахов кэша инструкций.
</p><p>
Некоторые пины работают только на вход и не могут быть переконфигурированы в режим выхода.
</p>

<p id="pin"><h2><a href="#top">&#8686;</a>КОМАНДА "PIN": УНИВЕРСАЛЬНЫЙ ИНСТРУМЕНТ ДЛЯ РАБОТЫ С GPIO</h2></p><p>

В ESPShell вы можете работать с GPIO с помощью команды "<b>pin</b>", которая используется как для отображения информации о конкретном пине, так и для его настройки. Вы можете установить пин в состояние HIGH или LOW, отправлять различные последовательности импульсов, включать или отключать ШИМ, настраивать направление и режим пина, а также работать с IO_MUX и GPIO Matrix для сложных конфигураций. Всё это можно делать вручную, без необходимости циклов правки/компиляции/загрузки/проверки.
</p>
<p>
В отличие от <i>digitalRead(...)</i>, который не работает на пинах, используемых аппаратными интерфейсами (например, нельзя использовать <code>digitalRead()</code> на линиях I<sup>2</sup>C), ESPShell может читать цифровые значения на <b>любом</b> GPIO. Он использует низкоуровневый доступ к состояниям пинов, поэтому безопасно читать значение пина, даже если на нём активен ШИМ. Для этого используется команда "<b>pin NUM read</b>".
</p>
<p>
Команда "<b>pin</b>" принимает несколько аргументов, которые обрабатываются слева направо. Первый аргумент — номер пина, остальные — ключевые слова и/или дополнительные номера пинов для применения операций. Эти аргументы можно рассматривать как простую программу, выполняемую на указанных пинах.
</p><p>
Например, "<b>pin 2 save out high load</b>" — валидная команда с четырьмя аргументами/ключевыми словами. Она сохраняет состояние GPIO2 во внутреннем регистре, переводит пин 2 в режим OUTPUT, устанавливает его в HIGH и сразу восстанавливает исходное состояние.
</p><p>
Примеры валидных команд "<b>pin</b>":
</p><p><pre>
    pin 1 high 2 low
    pin 2 pwm 1000 0.5 delay 250 pwm 1000 0.25 delay 250 loop infinite
</pre>
</p>

<p>
Команда "<b>pin</b>" может работать с одним или несколькими пинами одновременно. Пример ниже показывает команду, которая устанавливает пины 2 и 4 в HIGH, а пины 18 и 19 — в LOW:
<pre>
esp32#>pin 2 high 4 high 18 low 19 low
</pre>
Здесь 2, 4, 18 и 19 — номера пинов, а "low" и "high" — <i>ключевые слова</i>. Ключевые слова могут встречаться несколько раз и в различных комбинациях в одной команде "<b>pin</b>", как показано в <a href="GPIO.html#examples">разделе с примерами</a> ниже.
</p>

<p id="displaying"><H2><a href="#top">&#8686;</a>ОТОБРАЖЕНИЕ ИНФОРМАЦИИ О ПИНЕ</h2></p>

<p>
Чтобы отобразить информацию о произвольном пине: введите "<b>pin</b>", затем номер пина и нажмите &lt;Enter&gt;.
</p><p>
Пример ниже показывает базовую информацию о GPIO 0, 8, 1 и 4 (ESP32 DevKit):
</p><p><pre>
esp32#>pin 0
% GPIO0 is unused, strapping pin
% Mode: INPUT, PULL_UP,
% Output is disabled
% Input is done via IO MUX, (function: GPIO0)
% Maximum drive current is 20 mA
% Digital pin value is HIGH (1)
%
esp32#>pin 8
% GPIO8 is in use
% Mode: INPUT, OUTPUT, PULL_UP,
% Output is done via GPIO Matrix, provides path for signal ID: 2
% Input is done via GPIO Matrix, connected signal IDs: 2,
% Maximum drive current is 20 mA
% Digital pin value is LOW (0)
%
esp32#>pin 1
% GPIO1 is in use, configured as UART_TX
% Mode: INPUT,  input is floating
% Output is disabled
% Input is done via IO MUX, (function: U0TXD)
% Maximum drive current is 20 mA
% Digital pin value is HIGH (1)
%
esp32#>pin 4
% GPIO4 is unused
% Mode: INPUT, PULL_DOWN,
% Output is disabled
% Input is done via IO MUX, (function: GPIO4)
% Maximum drive current is 20 mA
% Digital pin value is LOW (0)
%
esp32#></pre>
</p>
<p id="show_pin">
Связанная команда "<b>show pin</b> <i>NUM</i>" эквивалентна "<b>pin</b> <i>NUM</i>" — обе отображают информацию о пине с номером <i>NUM</i>. 
Единственное отличие в том, что "<b>show pin</b>" принимает несколько аргументов (номеров пинов), поэтому пример выше можно записать одной командой: "<b>show pin 0 8 1 4</b>".
</p>

<p>
Обратите внимание, что некоторые пины <i>зарезервированы</i>: они используются внутри SoC. 
Это могут быть пины для доступа к flash-памяти или управления внешней PSRAM. Такие пины будут помечены как "<b>is reserved</b>".
</p>

<!-- p align=center>
<img src=pin_reserved.jpg alt="Reserved GPIO26" width="50%" height="50%" />
<br>
<i>Рис. 1: Пин 26 зарезервирован на ESP32-S3 DevKit</i>
</p -->

<p>
Сколько пинов доступно на вашей плате ESP32? Чтобы узнать, какие пины существуют, а какие нет, можно использовать команду "<b>pin</b>" без аргументов:
</p>
<p align=center>
<img src="i/pin_exist.jpg" alt="pin" width="50%" height="50%" />
<br>
<i>Рис. 1: Вывод команды "pin" (на ESP32-WROOM32D Dev Module)</i>
</p>

<p id="settings"><h2><a href="#top">&#8686;</a>НАСТРОЙКА РЕЖИМА ПИНА</h2>
</p>
<p>Команда <b>pin</b> используется для установки <i>режима</i> пина (например, PULL_UP/PULL_DOWN, INPUT/OUTPUT, OPEN_DRAIN) и его <i>значения</i>; эквивалент <i>pinMode()</i> и/или <i>digitalRead()/digitalWrite()/analogRead()</i>.</p>
<p>
<table><tr><td><b>Ключевое слово</b></td><td><b>Описание и примеры</b></td></tr>
<tr>
<td><p><i>NUMBER</i></p></td><td><p><b>pin </b><i>PIN_NUMBER</i><br />Номер пина для работы. Первый аргумент команды "pin" — это номер пина. Этот <i>номер пина</i> может встречаться несколько раз в одной команде "pin". Пример ниже устанавливает пины 0, 1 и 2 в LOW:<br>
<pre>
            esp32#>pin 0 low 1 low 2 low
</pre></p><p>
Команда, содержащая только числа в качестве аргументов (например, "pin 1 2 3"), является валидной, но ничего не делает.
</p></td></tr>

<tr><td><p>out</p></td><td><p><b>pin </b><i>PIN_NUMBER</i> <b>out</b><br />Установить пин в режим OUTPUT: эквивалент <i>pinMode(pin, OUTPUT)</i>.</p></td></tr>
<tr><td><p>in</p></td><td><p><b>pin </b><i>PIN_NUMBER</i> <b>in</b><br />Установить пин в режим INPUT: аналогично <i>pinMode(pin, INPUT)</i>.</p></td></tr>
<tr><td><p>up</p></td><td><p><b>pin </b><i>PIN_NUMBER</i> <b>up</b><br />Включить слабый внутренний подтягивающий резистор (~45 кОм), флаг PULL_UP.</p></td></tr>
<tr><td><p>down</p></td><td><p><b>pin </b><i>PIN_NUMBER</i> <b>down</b><br />Включить слабый внутренний подтягивающий резистор вниз, флаг PULL_DOWN.</p></td></tr>
<tr><td><p>open</p></td><td><p><b>pin </b><i>PIN_NUMBER</i> <b>open</b><br />Настроить пин на работу в режиме "open drain", OPEN_DRAIN.</p></td></tr>
</table>
<p>
Обратите внимание, что режим пина не добавляется к текущей конфигурации — он перезаписывается. 
Например, если мы установим пин 2 в OUTPUT с PULL_UP командой "<code>pin 2 out up</code>", 
а затем попытаемся добавить флаг INPUT с помощью "<code>pin 2 in</code>", пин 2 останется только с флагом INPUT.
</p>
<p>
Правильный способ применить несколько флагов — указать их все сразу, например: "<code>pin 2 in out up</code>".
Если команда <b>pin</b> включает любое из упомянутых выше ключевых слов режима, текущий режим пина сначала сбрасывается, а затем применяется новый.
</p>


<p id="reading"><h2><a href="#top">&#8686;</a>ЧТЕНИЕ/ЗАПИСЬ ЗНАЧЕНИЙ ПИНА</h2></p>

<table>
  <tr>
    <td><b>Ключевое слово</b></td>
    <td><b>Описание и примеры</b></td>
  </tr>

  <tr>
    <td>read</td>
    <td>
      <p><b>pin </b><i>PIN_NUMBER</i> <b>read</b></p>
      <p>Выполняет цифровое чтение.</p>
      <p>Команда "<code>pin 2 read</code>" выполняет <code>digitalRead()</code> на пине 2 и показывает результат (HIGH или LOW).</p>
      <p>
        Пины, настроенные только на OUTPUT, будут временно переключены в INPUT/OUTPUT автоматически. 
        В отличие от стандартного <code>digitalRead()</code>, эта команда может читать значение <b>любого</b> GPIO, независимо от его текущей конфигурации или использования — 
        например, она может читать значения с пинов, используемых для UART или I<sup>2</sup>C.
      </p>
      <p>
        <pre>
Пример: чтение значений GPIO#1.

  esp32#>pin 1 read
  % GPIO1 : logic 1

  esp32#>pin 1 read
  % GPIO1 : logic 0
  esp32#>
        </pre>
        В примере выше пин 1 сначала возвращает "1", а затем "0". 
        Это происходит потому, что на ESP32 GPIO1 обычно используется как UART_TX.
      </p>
    </td>
  </tr>

  <tr>
    <td><p>aread</p></td>
    <td>
      <p><b>pin </b><i>PIN_NUMBER</i> <b>aread</b></p>
      <p>Выполняет аналоговое чтение.</p>
      <p>
        Эта команда настраивает однократное измерение АЦП (Аналого-Цифрового Преобразователя) на указанном пине и возвращает <b>абсолютное</b> значение АЦП. В зависимости от настройки ослабления АЦП значения могут быть от 0 до 4095.
      </p>
    </td>
  </tr>

  <tr>
    <td><p>low</p></td>
    <td><p><b>pin </b><i>PIN_NUMBER</i> <b>low</b></p><p>Устанавливает логический "0" на пине.</p></td>
  </tr>

  <tr>
    <td><p>high</p></td>
    <td>
  <p><b>pin </b><i>PIN_NUMBER</i> <b>high</b></p>
      <p>Устанавливает логическую "1" на пине (т.е. <code>digitalWrite(pin, HIGH)</code>).</p>
      <p>
        Оба ключевых слова <code>high</code> и <code>low</code> автоматически устанавливают режим OUTPUT для пина, если он ещё не установлен.
        Поэтому следующие команды функционально эквивалентны:
      </p>
      <p>
        <pre>
"pin 2 high"
"pin 2 out high"
        </pre>
      </p>
    </td>
  </tr>
</table>

<p id="pulse"><h2><a href="#top">&#8686;</a>СИГНАЛЬНЫЕ ПОСЛЕДОВАТЕЛЬНОСТИ, PWM И ТАЙМИНГИ</h2></p>

<p>
Команда "<b>pin</b>" может использоваться для генерации ШИМ-сигналов, точных высокочастотных импульсных последовательностей (с модуляцией или без, подходящих для ИК-приёмников),
а также для сверхнизкочастотных сигналов и пользовательских шаблонов.
</p>

<table>
  <tr>
    <td><b>Ключевое слово</b></td>
    <td><b>Описание и примеры</b></td>
  </tr>

  <tr>
    <td><b>sequence</b>&nbsp;<i>NUM</i></td>
    <td>
      <p><b>pin </b><i>PIN_NUMBER</i> <b>sequence</b> <i>SEQUENCE_ID</i></p>
      <p>Передаёт <b>предварительно заданный</b> шаблон сигнала. Шаблоны создаются с помощью команды <a href="Pulse_Generator.html">sequence</a> и идентифицируются по <i>ID номеру</i>.</p>
      <pre>
Example: Send sequence 5 over pin 2:
  
  esp32#>pin 2 seq 5
      </pre>
    </td>
  </tr>

  <tr>
    <td><b>pwm</b>&nbsp;<i>FREQ</i>&nbsp;<i>DUTY</i></td>
    <td>
      <p><b>pin </b><i>PIN_NUMBER</i> <b>pwm</b> <i>FREQUENCY</i> <i>DUTY</i></p>
      <p>
        Включает ШИМ-выход на указанном выводе. <code>FREQ</code> — это частота в герцах, а <code>DUTY</code> — скважность.
        Оба параметра обязательны. Установка частоты в 0 отключает генерацию ШИМ.
        <code>DUTY</code> — это число с плавающей точкой в диапазоне (0..1).
      </p>
      <pre>
Example: Enable PWM at 5kHz with 50% duty cycle on pin 2:
  
  esp32#>pin 2 pwm 5000 0.5
      </pre>
      <p>
        Примечание: хотя команда <a href="PWM.html"><b>pwm</b></a> делает то же самое, что и "<code>pin &lt;PIN&gt; pwm &lt;FREQ&gt; &lt;DUTY&gt;</code>", 
        отдельная команда <b>pwm</b> предоставляет больше параметров для настройки.
      </p>
    </td>
  </tr>

  <tr>
    <td><b>delay</b>&nbsp;<i>NUM</i></td>
    <td>
      <p><b>pin </b><i>PIN_NUMBER</i> <b>delay</b> <i>MILLISECONDS</i></p>
      <p>
        Вставляет задержку в <i>NUM</i> миллисекунд перед выполнением следующего ключевого слова в последовательности команды "<b>pin</b>". 
        Это может использоваться для создания простых временных шаблонов:
      </p>
      <pre>
Example: Blink an LED connected to pin 2 at 0.5Hz:
  
  esp32#>pin 2 high delay 1000 low delay 1000 loop infinite &
      </pre>
      <p>
        Пример выше устанавливает на выводе 2 уровень HIGH на 1 секунду, затем LOW на 1 секунду, и повторяет цикл. 
        Символ <a href="Basics.html#background">"&"</a> запускает команду в фоновом режиме.
      </p>
    </td>
  </tr>
</table>


<p id="saving"><h2><a href="#top">&#8686;</a>СОХРАНЕНИЕ / ВОССТАНОВЛЕНИЕ СОСТОЯНИЯ ВЫВОДА, УДЕРЖАНИЕ СОСТОЯНИЯ</h2></p>

<p>
Можно временно сохранить состояние вывода (т.е. режим, значение и функцию IOMUX), а затем восстановить его. 
Для хранения используется внутренняя стековая структура, но она поддерживает только один уровень — то есть новая операция <b>save</b> перезапишет предыдущую.
Ключевые слова "<b>save</b>" и "<b>load</b>" используются для сохранения и восстановления состояния вывода. 
Также можно зафиксировать (заморозить) выходное значение вывода, чтобы предотвратить любые изменения. Однако как только заморозка будет снята, 
все изменения, сделанные во время фиксации, будут применены немедленно, как будто они были отложены. Для этого используются ключевые слова "<b>hold</b>" и "<b>release</b>".
</p>

<table>
  <tr><td><b>Ключевое слово</b></td><td><b>Описание и примеры</b></td></tr>

  <tr>
    <td><b>hold<br>release</b></td>
    <td>
      <p><b>pin </b><i>PIN_NUMBER</i> <b>hold | release</b></p>
      <p>
        Замораживает выходное значение вывода. Замороженный вывод сохраняет своё значение даже после программной перезагрузки, если питание продолжает подаваться на чип.
        Однако полная перезагрузка с отключением питания (POWERUP) снимает заморозку.
      </p>
      <pre>
Example: Freeze the value of pin 2:

  esp32#>pin 2 hold
      </pre>

      <p>
        "<b>pin X release</b>" снимает заморозку с вывода, ранее зафиксированного с помощью "<b>pin X hold</b>", и применяет все изменения, сделанные в период заморозки.
      </p>
      <pre>
Example: Unfreeze pin 2:

  esp32#>pin 2 release
      </pre>
    </td>
  </tr>

  <tr>
    <td><b>save<br>load</b></td>
    <td>
      <p><b>pin </b><i>PIN_NUMBER</i> <b>save | load</b></p>
      <p>Сохраняет состояние вывода во внутренний регистр и восстанавливает его позже с помощью "<b>load</b>".</p>
      <pre>
Example: Save pin state, perform analog read, then restore pin state:

  esp32#>pin 2 save aread load
      </pre>
      <p>
        "<b>pin X load</b>" восстанавливает ранее сохранённое состояние вывода. Пример выше демонстрирует использование ключевого слова "<b>load</b>".
      </p>
    </td>
  </tr>
</table>


<p id=loop><h2><a href="#top">&#8686;</a>АВТОПОВТОР КОМАНДЫ</h2></p>

<p>
Команду <b>"pin"</b> можно зациклить для повторения до тех пор, пока <i>количество повторений</i> не станет равным нулю. Для этого используется ключевое слово <b>loop</b>, которое должно быть размещено в конце команды.  
Цикличные команды можно прервать, нажав клавишу (для команд, работающих в переднем плане), или с помощью команды <b>"kill"</b> для остановки команд в фоновом режиме.
</p>

<table>
<tr><td><b>Ключевое слово</b></td><td><b>Описание и примеры</b></td></tr>
<tr>
<td><b>loop</b></td>
<td>
<p><b>pin</b> <i>НОМЕР_ПИНА</i> ... <b>loop</b> <i>COUNT</i>| <b>infinite</b></p>
<p>
  Повторяет всю команду <code>COUNT</code> раз. Ключевое слово <b>"loop COUNT"</b> должно быть в конце команды.  
  <code>КОЛИЧЕСТВО</code> также может быть <b>"бесконечно"</b>, что задает количество повторений равным 2^32-1, что фактически является бесконечным числом в большинстве случаев.
</p>
<p><pre>
    esp32#>pin 2 delay 1000 loop inf &   &larr; Фоновая команда, повторяется бесконечно
    esp32#>pin 2 delay 1000 loop 10 &    &larr; Фоновая команда, повторяется 10 раз
</pre></p>
</td>
</tr>
</table>

<p id="iomux"><h2><a href="#top">&#8686;</a>IO_MUX и GPIO MATRIX</h2></p>

<p>
IO_MUX и GPIO_Matrix (с подчеркиванием или без) — это аппаратные блоки внутри микросхемы ESP32.  
Они используются для подключения выводов GPIO к периферийным аппаратным модулям внутри ESP32.  
Каждый пин может быть настроен на одну из пяти (или шести на некоторых моделях ESP32) <i>функций</i>.  
Пин может использоваться как обычный GPIO или выполнять специализированную функцию (например, UART TX).  
Команда "<b>show iomux</b>" отображает текущие соответствия между пинами и функциями:
</p>

<p align="center">
  <img src="i/show_iomux.jpg" width="70%" height="70%" alt="вывод команды show iomux" /><br>
  <i>Рис. 2: Вывод команды <b>show iomux</b></i>
</p>

<p>
<ul>
  <li>Текущая активная функция отображается инвертированным цветом (или помечается "*" на монохромных дисплеях).</li>
  <li>Пины, которые активно используются (т.е. имеют установленный драйвер), отмечены красным и знаком восклицания ("<b>!</b>").</li>
  <li>Пины, помеченные зелёным, являются только входными (не могут использоваться как выход).</li>
</ul>
</p>

<p>
На примере вывода выше видно, что GPIO0 назначен на функцию 0 (обычный GPIO0).  
Изменение его на функцию 2 не повлияет на поведение, так как обе функции соответствуют "простому GPIO" —  
Функция 0 маршрутизируется через IO_MUX, а функция 2 — через GPIO_Matrix.
</p>

<p>
Пины с 6 по 11, отмеченные красным на рисунке 2, используются для доступа к встроенной флеш-памяти.
</p>

<p>
IO_MUX обеспечивает немного более высокую производительность по сравнению с GPIO_Matrix.  
Однако GPIO_Matrix предоставляет большую гибкость, позволяя почти любую периферию подключать к почти любому пину.  
Использование GPIO_Matrix для сигналов флеш-памяти (вместо IO_MUX) добавляет небольшую задержку около 25 нс.
</p>

<p>
Если снова взглянуть на рисунок 2, вы заметите, что пины 1 и 3 установлены на функцию №0, которая соответствует UART0 TX и UART0 RX соответственно.  
Означает ли это, что только пины 1 и 3 можно использовать для настройки UART0?
</p>

<p>
Нет, не означает.
</p>

<p>
UART0 также может быть настроен через GPIO Matrix — именно это происходит, когда вы назначаете UART0 на пины, отличные от 1 и 3.  
Например, если мы хотим инициализировать UART0 на пинах 18 и 19, эти пины будут переведены в режим <i>GPIO Matrix</i>, что отображается выбором функции №2 (на ESP32; на других моделях ESP используется функция №1).  
После выбора режима GPIO Matrix, пины подключаются к <i>периферийным сигналам</i> UART0_RX и UART0_TX.  
Маршрутизация сигналов (т.е. подключение или отключение) может также выполняться вручную — см. ключевое слово "<b>matrix</b>" ниже.
</p>

<p>
Снова, рисунок 2 показывает, что если мы хотим инициализировать UART1 на его предпочтительных пинах (т.е. через IO_MUX, минуя GPIO Matrix), нужно использовать GPIO9 и GPIO10.  
Когда эти пины настроены на функцию №4, они становятся UART1_RX и UART1_TX.  
К сожалению, GPIO9 и GPIO10 уже используются для подключения к микросхеме флеш-памяти.
</p>

<p>
Что насчёт UART2?  
Если его инициализировать на пинах 16 и 17 с выбранной функцией №4, они становятся пинами высокоскоростного интерфейса UART.  
Таким образом, пины 16 и 17 являются <i>предпочтительными</i> для UART2.  
Создадим интерфейс UART2 и снова взглянем на таблицу IOMUX:
</p>

<pre>
esp32#>uart 2
esp32-uart2>up 16 17 115200
esp32-uart2>show iomux
</pre>

<p align="center">
<img src="i/uart2_1617.jpg" width="70%" height="70%" alt="вывод команды show iomux" /><br>
<i>Рис. 3: Вывод команды <b>show iomux</b> после инициализации UART2 на предпочтительных пинах</i>
</p>

<p>
Что произойдёт, если мы инициализируем UART2 на пинах 18 и 19?  
Давайте посмотрим:
</p>

<pre>
esp32#>uart 2
esp32-uart2>up 18 19 115200
esp32-uart2>show iomux
</pre>

<p align="center">
<img src="i/uart2_1819.jpg" width="70%" height="70%" alt="вывод команды show iomux" /><br>
<i>Рис. 4: Вывод команды <b>show iomux</b> после инициализации UART2 на альтернативных пинах</i>
</p>

<p>
На этот раз пины установлены на функцию №2, которая соответствует режиму GPIO Matrix, что приводит к немного более медленной работе UART.  
Если вы выполните команду <code>show pin 18 19</code>, то увидите, что пины 18 и 19 подключены к <i>периферийным сигналам</i> UART2_RX и UART2_TX:
</p>

<pre>
esp32-uart2>sh pin 18 19
% GPIO18 is available, configured as UART_RX
% Mode: INPUT, input is floating
% Output is disabled
% Input is done via GPIO Matrix, connected signal IDs: 198,
% Maximum drive current is 20 mA
% Digital pin value is LOW (0)
%
% GPIO19 is available, configured as UART_TX
% Mode: INPUT, OUTPUT, input is floating
% Output is done via GPIO Matrix, provides path for signal ID: 198
% Input is done via GPIO Matrix
% Maximum drive current is 20 mA
% Digital pin value is HIGH (1)
</pre>


<p id="speed"><h2><a href="#top">&#8686;</a>ЗАМЕЧАНИЯ О СКОРОСТИ ИСПОЛНЕНИЯ</h2></p>
<p>
Команда "<b>pin</b>" является <i>интерпретатором</i>; она не <i>компилирует</i> свои ключевые слова для более быстрой обработки. Вместо этого ключевые слова <i>интерпретируются</i> каждый раз при их выполнении, даже внутри циклов. Так насколько быстро это работает?
</p>
<p>
Вы можете провести простой эксперимент: соедините пины 2 и 4 перемычкой и выполните команду "<b>pin 2 low high loop infinite &</b>" и "<b>count 4</b>".  
Первая команда переключает пин 2 между высоким и низким состоянием в фоновом цикле, а вторая команда подсчитывает импульсы, поступающие на пин 4.  
На классическом ESP32, работающем на 240 МГц, этот эксперимент показывает частоту импульсов около 80 кГц.  
Однако добавление всего лишь 1-миллисекундной задержки значительно снижает скорость исполнения:  
команда "<b>pin 2 low high delay 1 loop infinite &</b>" дает сигнал частотой около 500 Гц.
</p>
<p>
Другим фактором, который может повлиять на производительность команды "<b>pin</b>", является длина ключевых слов.  
ESPShell выполняет команды немного быстрее, если аргументы <i>сокращены</i>.  
Например, "<b>pin 2 l h loo inf &</b>" выполнится немного быстрее, чем "<b>pin 2 low high loop infinite &</b>".
</p>
<p>
Еще один важный момент: команды, такие как "<b>pin 2 low high loop inf &</b>", можно остановить только с помощью команды "<b><a href="Kill_Suspend_And_Resume.html">kill -9</a></b>".  
Это потому, что такие команды не содержат <b>задержек</b>, а задержки — это единственные точки, где команда "<b>kill</b>" (без "<b>-9</b>") может аккуратно прервать задачу.  
Для аккуратного завершения вы можете либо добавить задержку в 1 мс (что, как показано выше, значительно снижает производительность), либо использовать "<b>kill -9</b>", чтобы принудительно завершить задачу.
</p>

<p id="examples"><h2><a href="#top">&#8686;</a>ПРИМЕРЫ</h2></p>

<p>
Рассмотрим несколько простых примеров, демонстрирующих, как использовать команду "<b>pin</b>". 
Часто легче учиться на примерах, чем читать бесконечные таблицы и описания.
</p>

<p><b>Пример </b>1. Отобразить информацию о GPIO4:</p>
<p><pre>
   esp32#>pin 4
</pre></p>

<p><b>Пример </b>2. Установить пин 33 в режим OUTPUT и INPUT, включить PULL_UP и установить его в состояние HIGH:</p>
<p><pre>
   esp32#>pin 33 out in up high
</pre></p>

<p><b>Пример </b>3. Сохранить состояние пина, установить его в режим OUTPUT и HIGH, затем восстановить исходное состояние:</p>
<p><pre>
   esp32#>pin 33 save out high
   esp32#>pin 33 load
</pre></p>

<p>
   ПРИМЕЧАНИЕ: Установка пина в "low" или "high" автоматически устанавливает его в режим OUTPUT. 
   Внутренне ключевое слово "high" расширяется в "out high". 
   Поэтому вышеуказанную команду можно упростить до:
</p>
<p><pre> 
   esp32#>pin 33 save high
   esp32#>pin 33 load
</pre></p>

<p><b>Пример </b>4. Прочитать аналоговое значение с пина 33:</p>
<p><pre>
   esp32#>pin 33 aread
</pre></p>

<p>
   ПРИМЕЧАНИЕ: Команда "aread" использует функцию <code>analogRead()</code>, 
   которая перенастроит пин как часть процесса чтения. 
   После выполнения "<b>pin 33 aread</b>" пин будет перенастроен и может больше не отвечать на <code>digitalRead()</code>. 
   Чтобы сохранить исходную конфигурацию, используйте "save" и "load":
</p>
<p><pre>
   esp32#>pin 33 read save aread load
</pre></p>

<p>
   Аргументы обрабатываются слева направо. 
   В данном случае пин сначала читается цифрово, затем его состояние сохраняется, после чего выполняется аналоговое чтение и восстановление состояния.
</p>

<p>
<b>Пример </b>5. Сохранить состояние пина, установить его в режим OUTPUT и HIGH на 250 мс, LOW на 100 мс, снова HIGH на 50 мс, затем восстановить исходную конфигурацию:
</p>
<p><pre>
  esp32#>pin 33 save high delay 250 low delay 100 high delay 50 load
</pre></p>

<p>
  ПРИМЕЧАНИЕ: Хотя простые сигнальные паттерны можно создать с использованием "delay", эта команда обычно используется для базовых задач, таких как управление реле. 
  Для более сложных сигналов рекомендуется использовать Генератор импульсов. Дополнительную информацию см. в <code>docs/Pulse_Generator.txt</code>.
</p>

<p>
  ПРИМЕЧАНИЕ: Команду "pin" можно прервать во время длительных задержек (>5 секунд), нажав любую клавишу в терминале 
  или отправив любой символ через Serial Monitor в Arduino IDE. 
  Короткие задержки не могут быть прерваны — вам нужно дождаться их завершения.
</p>

<p><b>Пример </b>7. Установить пин 2 в HIGH, пин 3 в LOW, подождать 1 секунду, затем инвертировать состояния пинов:</p>
<p><pre>
  esp32#>pin 2 high 3 low delay 1000 2 low 3 high
</pre></p>

<p><b>Пример </b>8. Моргание светодиода на GPIO2 с задержкой 500 мс, 20 раз:</p>
<p><pre>
  esp32#>pin 2 high delay 500 low delay 500 loop 20
</pre></p>

<p>
  ПРИМЕЧАНИЕ: Когда используется ключевое слово "loop", команда "pin" становится <i>прерываемой</i>: 
  нажатие любой клавиши в терминале или Serial Monitor в Arduino IDE прервет выполнение команды.
</p>

<p><b>Пример </b>9. Моргание светодиода на GPIO2 при яркости 30%:</p>
<p>
  Для регулировки яркости используйте PWM с частотой 5 кГц и скважностью 30%:
</p>
<p><pre>
  esp32#>pin 2 pwm 5000 0.3 delay 500 pwm 0 0 delay 500 loop infinite
</pre></p>

<p>
Как показано в приведенных примерах, некоторые команды "pin" могут занять много времени для выполнения. 
Команды с "loop" или большими значениями "delay" могут выполняться десятки секунд или даже минуты. 
Вы можете прервать их в любой момент, нажав <Enter> в вашем терминале или Serial Monitor.
</p>

<p><b>Пример </b>10. Отправить S.O.S. в Морзе, повторяя бесконечно:<br>
(Морзе для SOS — ...---..., команда разделена на две строки для удобства чтения.)
</p>
<p><pre>

  pin 2 h d 100 l d 100 h d 100 l d 100 h d 100 l d 300 h d 200 l d 100 h d 200 
        l d 100 h d 200 l d 300 h d 100 l d 100 h d 100 l d 100 h d 100 l d 500 loop inf

</pre></p>

<p>
<b>Пример </b>11. Соединить GPIO2 с GPIO4 так, чтобы установка GPIO2 в логическую 1 также устанавливала GPIO4 в логическую 1. GPIO2 управляет GPIO4, но не наоборот:
</p>
<p><pre>
  esp32#>pin 2 matrix in 208
  esp32#>pin 4 matrix out 208
</pre></p>

<p>
Номер сигнала 208 — один из немногих <i>пользовательских</i> сигналов, не подключенных к периферийному устройству, 
что делает его идеальным для соединений GPIO-to-GPIO.
</p>

<p><b>Пример </b>12. Подключить периферийный сигнал 77 к постоянному "1", а сигнал 78 к постоянному "0":</p>
<p><pre>
  esp32#>pin 0x38 matrix in 77
  esp32#>pin 0x30 matrix in 78
</pre></p>

<p>
Этот пример использует специальные виртуальные пины: 0x30 (постоянная 0) и 0x38 (постоянная 1). 
Эти пины могут использоваться как источники в маршрутизации GPIO-матрицы для фиксированных логических уровней.
</p>

<p align="center"><img src="i/virtual_pins.jpg" alt="show pin 0x30 0x38" width="75%" height="75%"></p>

<p><b>Пример </b>13. Мониторинг аналогового сигнала на пине 36:</p>
<p>
Используйте ключевые слова "aread", "delay" и "loop" для создания простого монитора:
</p>
<p><pre>
  esp32#>pin 36 aread delay 500 loop infinite
</pre></p>

<p>Эта команда работает в переднем плане и обновляет аналоговое значение каждые 500 мс.</p>

<p align="center"><img src="i/pin_aread.jpg" alt="pin 36 aread" width="75%" height="75%"></p>

</body>
</html>


