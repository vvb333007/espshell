<!DOCTYPE html>
<html lang="ru">
<head>
  <link rel="stylesheet" href="espshell.css">
  <title>ESPShell : Управление процессами : kill, suspend и resume</title>
</head>
<body>
<p align=center><a href="index.ru.html"><img src="i/espshell_logo.jpg" alt="ESPShell для Arduino :: Содержание" width="70%" height="70%" /></a></p>
<h3 align=center><a href="Kill_Suspend_And_Resume.ru.html">[ На русском ]</a>&nbsp;&harr;&nbsp;<a href="Kill_Suspend_And_Resume.html">[ English ]</a></h3>
<p>
  <ul>
    <li><a href="#process">Управление процессами</a></li>
    <li><a href="#suspend">Приостановка, возобновление и завершение</a></li>
  </ul>
</p>

<p id="process"><h2>УПРАВЛЕНИЕ ПРОЦЕССАМИ</h2></p>

<p>
Управление процессами реализовано с помощью трёх команд: <b>suspend</b>, <b>resume</b> и <b>kill</b>. Под процессами
имеются в виду задачи FreeRTOS: например, основная функция Arduino <i>loop()</i> обрабатывается отдельной задачей FreeRTOS с именем "loop",
то есть "<i>loop()</i>"  - это процесс.
</p>

<p>
Доступ к задачам и управление ими осуществляется по их TASK_ID (шестнадцатеричное число, например "0x3fca370c"),
за исключением основной задачи loop() Arduino: выполнение основного скетча можно контролировать, опустив параметр TASK_ID
в команде. То есть, чтобы приостановить скетч, вместо "suspend 0x12345678" можно использовать
команду "suspend" без аргументов.
</p>

<p>
Хорошо, но где взять эти task id?
</p>

<p>
Всё просто: каждая команда ESPShell, которая запускается как процесс, всегда выводит свой TASK_ID. Допустим, мы запускаем команду "pin 2 delay 1000" в фоновом режиме:
<pre>
esp32#>pin 2 delay 1000 &
% Background task started
% Copy/paste "kill 0x3ffb91dc" to abort
esp32#>
</pre>
Эта простая команда ничего не делает, кроме как ждёт 1000 мс. После запуска она выводит свой task id и команду, которую можно скопировать и выполнить: "kill 0x3ffb91dc".
</p>

<p>
Другим источником TASK_ID является команда "<b><a href="Pulse_Counter.ru.html#show">show counters</a></b>"
</p>

<p id="suspend"><h2>ПРИОСТАНОВКА, ВОЗОБНОВЛЕНИЕ И ЗАВЕРШЕНИЕ</h2></p>

<table>
  <tr><th>Команда</th><th>Описание и примеры</th></tr>

  <tr>
    <td><b>suspend</b></td>
    <td>
      <p>Приостанавливает выполнение скетча: приостанавливает <b>loop()</b> Arduino. Задачи, которые были запущены из <b>loop()</b> и <b>setup()</b>,
  <b>не приостанавливаются</b> этой командой. Приостановка задачи вместе со всеми её дочерними задачами  - запланированная, но пока не реализованная возможность.
 Комбинация клавиш Ctrl+C является горячей клавишей для команды "<b>suspend</b>"</p>
    </td>
  </tr>

  <tr>
    <td><b>suspend</b> <i>TASK_ID</i></td>
    <td>
      <p><b>suspend</b> <i>TASK_ID</i></p>
      <p>Приостанавливает произвольную задачу, если известен её идентификатор. Команда требует один
  аргумент  - идентификатор задачи (в шестнадцатеричном формате)</p>
    </td>
  </tr>

  <tr>
    <td><b>resume</b></td>
    <td>
      <p>Возобновляет выполнение скетча</p>
    </td>
  </tr>

  <tr>
    <td><b>resume</b> <i>TASK_ID</i></td>
    <td>
      <p><b>resume</b> <i>TASK_ID</i></p>
      <p>Возобновляет произвольную задачу, если известен её идентификатор. Команда требует один
  аргумент  - идентификатор задачи (в шестнадцатеричном формате)</p>
    </td>
  </tr>

</table>

<p>
Чтобы остановить задачу ESPShell (ESPShell <a href="Basics.ru.html#background">использует задачи</a> для запуска фоновых команд) или произвольную задачу FreeRTOS, можно воспользоваться
командой "<b>kill</b>":
</p>

<table>
  <tr><th>Команда</th><th>Описание и примеры</th></tr>

  <tr>
    <td><b>kill</b> <i>TASK_ID</i></td>
    <td><p>    "<b>kill</b> [-TERM | -15 | -KILL | -9] <i>TASK_ID</i>"</p>
<p>
Останавливает выполнение задачи с TASK_ID. Этот идентификатор либо выводится при запуске фоновой команды,
либо может быть произвольным идентификатором FreeRTOS-задачи. Если в конце команды используется символ "&",
то ESPShell выполняет такую команду в фоновом режиме, создавая новую задачу:
</p>
<p>
<pre>
      esp32#>pin 2 delay 999 &
      % Background task started
      % Copy/paste "kill 0x3fca370c" command to stop execution  &larr; обратите внимание на TASK_ID
      esp32#>
</pre>
</p>

<p>
В простейшем случае, когда используется только один параметр (TASK_ID), команда <i>отправляет уведомление</i>
задаче, которую нужно завершить, чтобы она могла завершиться корректно.
</p>
<p>
Команда старается имитировать классическую команду "kill" из Linux и принимает дополнительный параметр  -
<i>сигнал</i>, который нужно отправить: <b>-9</b> или <b>-KILL</b> означает принудительное завершение задачи. Уведомление не отправляется,
вместо этого задача приостанавливается и удаляется с помощью FreeRTOS API vTaskDelete(). При этом ресурсы, занятые задачей, не освобождаются.
Завершение задачи, которая удерживает мьютекс, может привести к зависаниям.
</p><p>
Все задачи, создаваемые ESPShell, должны завершаться таким образом  - без указания дополнительных параметров.
Однако есть примеры команд ESPShell, которые можно завершить только с помощью "kill -9", эти особые случаи описаны
<a href="GPIO.ru.html">в описании</a> команды "pin".
</p><p>
Опция <b>-15</b>, <b>-TERM</b> или её отсутствие означает "корректное завершение": задача не удаляется, а получает возможность завершиться самостоятельно и освободить все используемые ресурсы (если таковые имеются).
</p><p>
Опция <b>-9</b> или <b>-KILL</b> приводит к приостановке задачи с её последующим удалением через API FreeRTOS <i>vTaskDelete()</i>.
Эта опция эквивалентна команде Linux "kill -9", но в отличие от неё, ESPShell не освобождает ресурсы, которые могли быть выделены задачей.
</p>
    </td>
  </tr>

</table>
</body>
</html>
