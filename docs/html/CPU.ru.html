<!DOCTYPE html>

<html lang="ru">
<head>
  <title>ESPShell: CPU и память</title>
  <link rel="stylesheet" href="espshell.css">
  <meta charset="UTF-8">
</head>
<body>
<p align="center">
  <a href="index.ru.html"><img src="i/espshell_logo.jpg" alt="ESPShell для Arduino :: ЦПУ и память" width="70%" height="70%" /></a>
</p>
<h3 align=center><a href="CPU.ru.html">[ На русском ]</a>&nbsp;&harr;&nbsp;<a href="CPU.html">[ English ]</a></h3>

<ul>
  <li><a href="#set">Установка частоты CPU</a></li>
  <li><a href="#cpuid">Отображение информации о CPU</a></li>
  <li><a href="#meminfo">Отображение информации о памяти</a></li>
  <li><a href="#memdump">Просмотр содержимого памяти</a></li>
</ul>

<h2 id="set"><a href="#top">&#8686;</a> Установка частоты CPU</h2>
<p>Процессор ESP32 поддерживает изменение частоты во время выполнения. На классическом ESP32 основная частота CPU также может влиять на частоту шины APB: если частота CPU опускается ниже 80, то частота APB будет равна частоте CPU. Это повлияет на все тайминги ШИМ и других модулей, но вам не нужно об этом беспокоиться: ESPSHell пересчитывает все тайминги при изменении частоты APB.</p>

<table>
  <tr><th>Команда</th><th>Описание и примеры</th></tr>

  <tr>
    <td><b>cpu</b></td>
    <td>
      <p>Отображает список поддерживаемых частот:
<pre>
esp32#>cpu
% Supported frequencies are: 240, 160, 120, 80, 40, 20 and 10 MHz
esp32#>
</pre>
</p></td></tr>

<tr><td><b>cpu</b> <i>FREQ</i></td><td>
<p>Устанавливает частоту CPU в <i>FREQ</i> МГц (например, 240).</p>
<p>ESP32 поддерживает частоты 240, 160 и 80 МГц. В зависимости от частоты кварцевого генератора (XTAL) могут быть доступны и другие варианты, такие как XTAL / 4 и/или XTAL / 2.
Если задана неподдерживаемая частота, ESPShell отобразит список допустимых значений:</p>
<pre>
  esp32#>cpu 1
  % 1 MHz is an unsupported frequency
  % Supported frequencies are: 240, 160, 120, 80, 40, 20, and 10 MHz
  % Invalid 1st argument "1" ("? cpu" for help)
</pre>
</td></tr></table>

<h2 id="cpuid"><a href="#top">&#8686;</a> Отображение информации о CPU</h2>

<p><b>show cpuid</b></p>
<p>Отображает информацию о железе и программном обеспечении:</p>
<p align="center">
  <img src="i/show_cpuid.jpg" width="70%" height="70%" alt="show cpuid" /><br>
  <i>Рис. 1: Вывод команды "<b>show cpuid</b>"</i>
</p>
<p>
Вывод разделён на четыре секции: Аппаратная часть, Flash, Прошивка и Последняя загрузка.  
Первая секция показывает CPUID, частоту CPU, частоту XTAL, частоту шины APB и температуру ядра CPU.
</p>
<p>
Вторая секция содержит данные о flash-чипе: его размер и ID производителя.
</p>
<p>
Секция прошивки показывает версии компонентов, использованных при сборке прошивки/скетча, включая версию Arduino core  
(несоответствие версий — частая причина проблем), версию ESP-IDF и номер версии ESPShell.
</p>
<p>
Последняя секция включает вывод команды "<b>uptime</b>", отображающей время работы системы и причину последней перезагрузки.
</p>

<h2 id="meminfo"><a href="#top">&#8686;</a> Отображение информации о памяти</h2>

<p>ESPShell предоставляет две команды для отображения информации о памяти: <b>show memory</b> и <b>show memory</b> <i>ADDRESS</i> ...</p>

<table>
  <tr><th>Команда</th><th>Описание и примеры</th></tr>

  <tr>
    <td><b>show memory</b></td>
    <td>
      <p>Отображает общий объём и доступную память, видимую из скетча:</p>
      <p align="center">
        <img src="i/show_memory.jpg" width="70%" height="70%" alt="show memory" /><br>
        <i>Рис. 2: Результат работы команды "<b>show memory</b>"</i>
      </p>
      <p>
        <b>if using malloc()</b> - информация относящаяся к стандартному аллокатору (т.е. malloc, calloc, realloc, strdup, new и free)<br>
        <b>if using heap_caps..</b> - информация относящаяся к аллокатору ESP-IDF (т.е. heap_caps_alloc() и т.д.)<br>
      </p>
       Помимо стандартных free/total/allocated счетчиков, так же есть отметки самого большого потребления памяти с запуска скетча: это значение обновляется каждый раз, когда достигается очередной рекорд по потреблению памяти (такие отметки ведутся для SRAM и SPIRAM).
       Так же, обе кучи (SPIRAM и Internal SRAM) проверяются на целостность, и результат проверки выводится как <b>PASS</b> или <b>FAIL</b>
    </td>
  </tr>

  <tr id=memdump>
    <td><b>show memory</b> <i>ADDRESS</i></td>
    <td>
      <p><b>show memory</b> <i>ADDRESS</i> [ <i>COUNT</i> ] [signed|unsigned|float|void*|int|char|short]</p>
      <p>Отображает содержимое памяти, начиная с указанного адреса. Адрес должен быть в шестнадцатеричном формате, с префиксом "0x" или без него.</p>
      <p>В самой простой форме эта команда требует только один аргумент — адрес. Результатом будет дамп 256 байт, начиная с указанного адреса. Обратите внимание, что архитектура памяти ESP32 достаточно сложна: некоторые области доступны только через шину инструкций, некоторые — только с ядра CPU#0 (ESPSHell обычно работает на ядре #0), некоторые — только при доступе как к 32-битным словам и т.д. Espressif предоставляет документы с описанием карт памяти конкретных моделей ESP32:
      <a href="https://dl.espressif.com/public/esp32s3-mm.pdf">для ESP32-S3</a>, <a href="https://dl.espressif.com/public/esp32-mm.pdf">для ESP32</a> и т.д.</p>
<p>
<b>Пример:</b> Показ содержимого памяти начиная с адреса 0x3fc97a30
</p>
<pre>
    esp32#>sh mem 0x3fc97a30
           0  1  2  3   4  5  6  7   8  9  A  B   C  D  E  F  |0123456789ABCDEF
    ----------------------------------------------------------+----------------
    0000: 01 00 00 00  02 00 00 00  03 00 00 00  9d ff ff ff  |................
    0010: 0c 0c 03 00  0b 00 00 00  5c 32 ca 3f  00 00 00 00  |........\2.?....
    0020: 14 0e 09 3c  2c 2b ff ff  00 c2 01 00  1c 00 00 08  |...<,+..........
    0030: 00 01 00 00  00 70 00 00  00 00 00 00  01 00 00 00  |.....p..........
    0040: 00 00 00 00  ff ff ff ff  00 00 00 00  00 00 00 00  |................
    0050: 00 00 00 00  00 00 00 00  00 00 00 00  02 00 00 00  |................
    0060: 00 00 00 00  ff ff ff ff  00 00 00 00  00 00 00 00  |................
    0070: 00 00 00 00  00 00 00 00  c8 7a c9 3f  ff ff 3f b3  |.........z.?..?.
    0080: 00 00 00 00  03 00 00 00  00 00 00 00  00 00 00 00  |................
    0090: 00 00 00 00  00 00 00 00  00 40 00 60  c8 bb 07 3c  |.........@.`...<
    00a0: 00 00 00 00  cc bb 07 3c  00 00 00 00  d0 bb 07 3c  |.......<.......<
    00b0: 00 00 00 00  d4 bb 07 3c  00 00 00 00  d8 bb 07 3c  |.......<.......<
    00c0: 00 00 00 00  dc bb 07 3c  00 00 00 00  e0 bb 07 3c  |.......<.......<
    00d0: 00 00 00 00  e4 bb 07 3c  00 00 00 00  e8 bb 07 3c  |.......<.......<
    00e0: 00 00 00 00  ec bb 07 3c  00 00 00 00  f0 bb 07 3c  |.......<.......<
    00f0: 00 00 00 00  f4 bb 07 3c  00 00 00 00  f8 bb 07 3c  |.......<.......<
    esp32#>
</pre>
<p>Команда поддерживает необязательные аргументы — рассмотрим их</p>

      <h3>Необязательные аргументы: количество и тип</h3>

      <p>Чтобы задать количество элементов, используйте аргумент COUNT:</p>
<pre>
    esp32#>sh mem 0x3fc97a30 32
           0  1  2  3   4  5  6  7   8  9  A  B   C  D  E  F  |0123456789ABCDEF
    ----------------------------------------------------------+----------------
    0000: 01 00 00 00  02 00 00 00  03 00 00 00  9d ff ff ff  |................
    0010: 0c 0c 03 00  0b 00 00 00  5c 32 ca 3f  00 00 00 00  |........\2.?....
    esp32#>
</pre>
<p>Если COUNT не указан, по умолчанию будет показано 256 байт</p>

      <p>Чтобы интерпретировать данные как определённый тип, укажите один из следующих типов: "signed", "unsigned", "char", "short", "int" или "void *". При указании типа COUNT по умолчанию становится равным 1 вместо 256.</p>

      <p>Тип "void *" используется для 32-битного дампа в шестнадцатеричном виде. Некоторые области памяти ESP32 можно читать только как 32-битные слова:</p>
<pre>
esp32#>sh mem 0x50000000 void *
% 0x50000000 : 0x344dbbe1
esp32#>
</pre>
<p>ПРИМЕЧАНИЕ: хотя аргумент <i>COUNT</i> в приведённом выше примере не указан, ESPSHell выводит только 1 элемент, так как был задан <i>тип</i> (<b>void *</b>). Если вы хотите увидеть больше элементов, COUNT нужно задать явно:
<pre>
esp32#>sh mem 0x50000000 10 void *
% Array of 10 elements, 4 bytes each
%  Address   :  Value
% 0x50000000 : 0x344dbbe1
% 0x50000004 : 0x9d2aa486
% 0x50000008 : 0x476c2e42
% 0x5000000c : 0x40da87ea
% 0x50000010 : 0x607b4d64
% 0x50000014 : 0xfc28182e
% 0x50000018 : 0x97b54ec4
% 0x5000001c : 0xefe11d7a
% 0x50000020 : 0xd703bad6
% 0x50000024 : 0x698b7ad1
esp32#></pre>
<p>ПРИМЕЧАНИЕ: типы "void *", "void*" или просто "*" — все они означают одно и то же: данные будут интерпретированы как беззнаковые 32-битные значения и выведены в шестнадцатеричном формате</p>

      <p>Эта команда может быть использована для отображения содержимого массивов и переменных скетча, если известны их адреса</p>
<p><b>Пример:</b> Массив беззнаковых целых чисел расположен по адресу 0x3fc97a30. Показать первые 3 элемента массива</p>
<pre>
esp32#>sh mem 0x3fc97a30 3 unsigned int
% Array of 3 elements, 4 bytes each
%  Address   :  Value
% 0x3fc97a30 : 1 (0x1 as hex)
% 0x3fc97a34 : 2 (0x2 as hex)
% 0x3fc97a38 : 3 (0x3 as hex)
esp32#>
</pre>
    </td>
  </tr>
</table>

</body>
</html>
