ESP32Shell for the Arduino Framework by vvb333007 <vvb@nym.hush.com>


ESP32 PINS
----------

ESP32 has many pins (GPIO) which can be configured to be either a
general purpose pin (GPIO) or to bear some function: be a TX pin of
a hardware UART interface or be a CLOCK line for an I2C interface

Some pins have system functions: so called "bootstrapping" pins.
Their function is to tell the bootloader what to do on boot and
how to initialize the hardware.

Some pins are reserved for internal use: for example pins 6-11 on
most ESP32 Devboards are used to access internal flash: you can play
with these pins only if your program is fully in processor cache 
(be within 64kb which is impossible when using espshell)

Some pins are configured to be OUTPUT only and this can not be changed

In ESPShell one can play with GPIOs using "pin" command which is used
both for displaying pin information and configuring.


DISPLAYING PIN INFORMATION
--------------------------
To display informaton on arbitrary pin type "pin" followed by pin number.
Example below displays GPIO2 basic information:

  esp32#>pin 2
  % Digital pin value = 1
  IO[2] -
    Pullup: 0, Pulldown: 1, DriveCap: 2
    InputEn: 1, OutputEn: 1, OpenDrain: 0
    FuncSel: 2 (GPIO)
    GPIO Matrix SigOut ID: 256 (simple GPIO output)
    GPIO Matrix SigIn ID: (simple GPIO input)
    SleepSelEn: 0

The output above says that pin2 is currently HIGH, has a pulldown, has
both input and output enabled, pin drive capability is 2==medium==20mA

To get information on pin numbers and their availability one can try to
display information on non-existing pin (pin 999 as an example):

  esp32#>pin 999
  % Available pin numbers are are 0..39, except 24,28,29,30,31,
  % Invalid argument "999" ("pin ?" for help)
  esp32#>

Output above tells the pin range and shows pins which simply do not 
exists in this hardware 24,28,29,30,31


SETTING PIN MODE, READING/WRITING PIN VALUES
--------------------------------------------

(or scroll to Examples below :)

Command "pin" takes multiple argumens which are processed in order
from left to right. The first argument is a pin number and the rest
of arguments are keywords to execute. One can think of arguments as
of simple program to execute on given pin

Here is the list of allowed keywords:


up      - Set weak internal pull-up (~45kOhm)
down    - Set weak internal pull-down
out     - Set pin to be output (pinMode(OUTPUT))
in      - Set pin to be input
open    - Set pin "open drain" option
high    - Write logic "1" to the pin (digitalWrite(pin,HIGH))
low     - Write logic "0" to the pin

save    - Save pin configuration. each save rewrites previous save

load    - Load pin configuration. reads previously saved data. reading does not
          erase saved data.

read    - Digital read
aread   - Analog read*

hold    - "freeze" pin state and output value. Frozen pin remains frozen after
          reboot (as long as power to the chip is provided. rebooting via 
          POWERUP unfreezes pin) See NOTE(*) at the end of this document.

release - "unfreeze" pin which was "frozen" by "pin X hold" See NOTE(*) at the 
          end of this document

Multiple keywords can be used in single "pin" command (separated by spaces):
"pin 2 out open up" is a valid command, executing 3 keywords in sequence


Lets go through some simple examples which show the use of "pin" command.

Example 1. Dsiplay GPIO4 information:
-------------------------------------

   esp32#>pin 4


Example 2. Set pin 33 to OUTPUT and INPUT, PULL_UP, OPEN_DRAIN and HIGH:
------------------------------------------------------------------------

   esp32#>pin 33 out in up open high


Example 3. Save pin state, configure it to OUTPUT, HIGH, then restore pin state:
--------------------------------------------------------------------------------

   esp32#>pin 33 save out high
   esp32#>pin 33 load


Example 4. Read analog value from pin 33:
-----------------------------------------
   esp32#>pin 33 aread

   NOTE: analog read command ("aread") is implemented via analogRead() call which
   writes new configuration to the pin in the process of reading. In other words, 
   after "pin 18 aread" command is executed  pin 18 gets reconfigured (does not respond
   to digitalRead() afterwards). Use "save" and "load" keywords to preserve pin state:

   esp32#>pin 33 read save aread load

   Arguments are processed left to right: the command above perform a digitalRead()
   on the pin, then saves its state, performs analogRead and restores pin state.


Example 5, Save pin state, configure it for OUTPUT, set pin HIGH for 250 milliseconds then
   set it LOW for 100ms, then HIGH again for 50ms and finally restore the pin configuration:
--------------------------------------------------------------------------------------------

  esp32#>pin 33 save out high delay 250 low delay 100 high delay 50 load
  
  NOTE: although you can create simple signal patters with "delay" it is normally used for
  something simple, like relay control. Complex signal sequences could be configured with
  use of Pulse Generator (see docs/Pulse_Generator.txt)



(*)
Keyword "hold" makes pin to hold its state & output level until it 
release either by POWERDOWN or "pin release" command. When pin is frozen all 
attempts to write or configure it will be ignored by hardware. However when 
pin is released then it rereads last configuration issued:

Lets say we freeze pin 2 and then write 1 to it: since pin is frozen, it will
not change it walue from 0 to 1. However when we release the pin it immediately
becomes "logic 1" as if writing of an "1" was queued
