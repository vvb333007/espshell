Pin-related commands
--------------------

ESP32 has many pins (GPIO) which can be configured to be either a
general purpose pin (GPIO) or to bear some function: be a TX pin of
a hardware UART interface or be a CLOCK line for an I2C interface

Some pins have system functions: so called "bootstrapping" pins.
Their function is to tell the bootloader what to do on boot and
how to initialize the hardware.

Some pins are reserved for internal use: for example pins 6-11 on
most ESP32 Devboards are used to access internal flash: you can play
with these pins only if your program is fully in processor cache 
(be within 64kb which is impossible when using espshell)

Some pins are configured to be OUTPUT only and this can not be changed

All pin configuration is done by "pin" command:

To get basic information on pin numbers (which are available) one can
enter command "pin" with argument which is obviously not existing pin:

esp32#>pin 999
% Available pin numbers are are 0..39, except 24,28,29,30,31,
% Invalid argument "999" ("pin ?" for help)
esp32#>

Output above tells the pin range and shows pins which simply do not 
exists in this hardware 24,28,29,30,31

To get an arbitrary pin information type "pin" followed by pin number:

esp32#>pin 2
% Digital pin value = 1
================IO DUMP Start================
IO[2] -
  Pullup: 0, Pulldown: 1, DriveCap: 2
  InputEn: 1, OutputEn: 1, OpenDrain: 0
  FuncSel: 2 (GPIO)
  GPIO Matrix SigOut ID: 256 (simple GPIO output)
  GPIO Matrix SigIn ID: (simple GPIO input)
  SleepSelEn: 0

=================IO DUMP End==================

The output above says that pin2 is currently HIGH, has a pulldown, has
both input and output enabled, pin drive capability is medium(2)


Command "pin" takes multiple argumens which are processed in order
from left to right. Here is the list of allowed arguments(keywords):

up    - set weak internal pull-up (~45kOhm)
down  - set weak internal pull-down
out   - set pin to be output (pinMode(OUTPUT))
in    - set pin to be input
open  - set pin "open drain" option
high  - write logic "1" to the pin (digitalWrite(pin,HIGH))
low   - write logic "0" to the pin
save  - save pin configuration. each save rewrites previous save
load  - load pin configuration. reads previously saved data. reading does not erase saved data
read  - digital read
aread - analog read*

NOTE: analog read command ("aread") implemented via analogRead() call which
writes new configuration to the pin. Problem arises when one trying to perform 
digital read after analog read: reconfigured pin does not respond to digitalRead.
This however can be worked around with "load"  and "save" - see example below
 
Here are some simple examples which show the use of "pin" command:

1. Set pin 33 to OUTPUT,INPUT, PULL_UP, OPEN_DRAIN and then set pin 33 HIGH:

esp32#>pin 33 out in up open high

2. Read analog value from pin 33:

esp32#>pin 33 aread
% GPIO33 : analog 3664 (2814 mV)

Analog read command "pin 33 aread" rewrites pin configuration. To prevent
this one can use "save" and "load" keywords:

esp32#>pin 33 read save aread load

Arguments are processed left to right: the command above perform a digitalRead()
on the pin, then saves its state, performs analogRead and restores pin state.
Command "save" stores current pin state (but not IOMUX/GPIO matrix connections!)
which later can be retrieved by "load" command. Subsequent "save" commands rewrite
previous save. Subsequent "load" commands just copy saved data again and again.


Summary
-------

Show pin configuration : "pin X"
Show pin availability: "pin 999"
Configure pin 33 to be output opendrain pull-up GPIO: "pin 33 out open up"
Save pin state: "pin X save"
Using "load" and "save" to preserve pin state after analogRead():
"pin 33 read save aread load"
